// Generated by CoffeeScript 1.6.3
var EOFError, ID3, ID3NoHeaderError, ID3UnsupportedVersionError, Parser, Q, fs, _ref;

fs = require('fs');

Q = require('q');

Parser = require('./parser');

EOFError = require('../errors').EOFError;

_ref = require('./errors'), ID3NoHeaderError = _ref.ID3NoHeaderError, ID3UnsupportedVersionError = _ref.ID3UnsupportedVersionError;

Q.longStackSupport = true;

ID3 = (function() {
  function ID3(filepath) {
    Object.defineProperties(this, {
      filepath: {
        writable: true,
        value: null
      },
      unknownFrames: {
        writable: false,
        value: []
      },
      size: {
        writable: true,
        value: 0
      },
      version: {
        writable: true,
        value: {
          major: 2,
          minor: 4,
          sub: 0
        }
      },
      extSize: {
        writable: true,
        value: null
      },
      extData: {
        writable: true,
        value: null
      },
      _flags: {
        writable: true,
        value: 0
      }
    });
    if (arguments.length > 0) {
      this.load.apply(this, arguments);
    }
  }

  Object.defineProperties(ID3.prototype, {
    f_unsynch: {
      get: function() {
        return (this._flags & 0x80) !== 0;
      }
    },
    f_extended: {
      get: function() {
        return (this._flags & 0x40) !== 0;
      }
    },
    f_experimental: {
      get: function() {
        return (this._flags & 0x20) !== 0;
      }
    },
    f_footer: {
      get: function() {
        return (this._flags & 0x10) !== 0;
      }
    },
    PEDANTIC: {
      writable: false,
      value: true
    }
  });

  ID3.prototype.load = function(filepath, callback) {
    var closeFile, context, openingFile, parser, sizingFile,
      _this = this;
    this.filepath = filepath;
    context = {
      fd: null,
      fileSize: null,
      position: 0
    };
    parser = new Parser(this, context);
    openingFile = Q.nfcall(fs.open, filepath, 'r');
    sizingFile = Q.nfcall(fs.stat, filepath);
    closeFile = function() {
      var closing;
      closing = context.fd ? Q.nfcall(fs.close, context.fd) : true;
      context = null;
      parser = null;
      return closing;
    };
    return Q.all([openingFile, sizingFile]).spread(function(fd, stat) {
      context.fd = fd;
      context.fileSize = stat.size;
      return parser.loadHeader();
    }).then(function() {
      return parser.readV2Frames();
    }).fail(function(err) {
      var endOfFile, msg, noHeader, unsupportedVersion;
      endOfFile = err instanceof EOFError;
      noHeader = err instanceof ID3NoHeaderError;
      unsupportedVersion = err instanceof ID3UnsupportedVersionError;
      switch (false) {
        case !endOfFile:
          _this.size = 0;
          msg = "" + _this.filepath + ": too small (" + context.fileSize + " bytes)";
          throw new ID3NoHeaderError(msg);
          break;
        case !(noHeader || unsupportedVersion):
          _this.size = 0;
          if (context.fileSize < 128) {
            throw err;
          }
          return parser.readV1Frames().then(function(tag) {
            return tag || (function() {
              throw err;
            })();
          });
        default:
          throw err;
      }
    }).fin(closeFile).nodeify(callback);
  };

  ID3.prototype.add = function(frame) {
    return this[frame.HashKey] = frame;
  };

  ID3.prototype.loadFramedata = function(tag, flags, data) {
    return tag.fromData(tag, this, flags, data);
  };

  return ID3;

})();

module.exports = ID3;
