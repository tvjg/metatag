// Generated by CoffeeScript 1.6.3
var BitPaddedInt, EOFError, Frame, ID3, ID3JunkFrameError, ID3NoHeaderError, ID3UnsupportedVersionError, NotImplementedError, ParseID3v1, Q, ValueError, convert, fs, sprintf, unsynch, _ref, _ref1;

fs = require('fs');

Q = require('q');

sprintf = require("sprintf-js").sprintf;

convert = require('../text-encodings');

unsynch = require('./unsynch');

BitPaddedInt = require('../BitPaddedInt');

Frame = require('./frame').Frame;

_ref = require('../errors'), ValueError = _ref.ValueError, EOFError = _ref.EOFError, NotImplementedError = _ref.NotImplementedError;

_ref1 = require('./errors'), ID3NoHeaderError = _ref1.ID3NoHeaderError, ID3UnsupportedVersionError = _ref1.ID3UnsupportedVersionError, ID3JunkFrameError = _ref1.ID3JunkFrameError;

Q.longStackSupport = true;

ID3 = (function() {
  function ID3(filepath) {
    Object.defineProperty(this, 'PEDANTIC', {
      writable: false,
      value: true
    });
    Object.defineProperty(this, 'filepath', {
      writable: true,
      value: null
    });
    Object.defineProperty(this, 'size', {
      writable: true,
      value: 0
    });
    Object.defineProperty(this, 'unknownFrames', {
      writable: false,
      value: []
    });
    Object.defineProperty(this, 'version', {
      writable: true,
      value: {
        major: 2,
        minor: 4,
        sub: 0
      }
    });
    Object.defineProperty(this, 'extSize', {
      writable: true,
      value: null
    });
    Object.defineProperty(this, 'extData', {
      writable: true,
      value: null
    });
    Object.defineProperty(this, '_flags', {
      writable: true,
      value: 0
    });
    Object.defineProperty(this, 'f_unsynch', {
      get: function() {
        return (this._flags & 0x80) !== 0;
      }
    });
    Object.defineProperty(this, 'f_extended', {
      get: function() {
        return (this._flags & 0x40) !== 0;
      }
    });
    Object.defineProperty(this, 'f_experimental', {
      get: function() {
        return (this._flags & 0x20) !== 0;
      }
    });
    Object.defineProperty(this, 'f_footer', {
      get: function() {
        return (this._flags & 0x10) !== 0;
      }
    });
    if (arguments.length > 0) {
      this.load.apply(this, arguments);
    }
  }

  ID3.prototype.fullRead = function(context, size) {
    var readingFile,
      _this = this;
    if (size < 0) {
      throw new ValueError("Requested bytes " + size + " less than zero");
    }
    if ((context.fileSize != null) && size > context.fileSize) {
      throw new EOFError("Requested " + size + " of " + context.fileSize + " " + this.filepath);
    }
    readingFile = Q.nfcall(fs.read, context.fd, new Buffer(size), 0, size, context.position);
    return readingFile.spread(function(bytesRead, buff) {
      if (bytesRead !== size) {
        throw new EOFError('End of file');
      }
      context.position += bytesRead;
      return buff;
    });
  };

  ID3.prototype.load = function(filepath, callback) {
    var closeFile, context, openingFile, parseV1Frames, parseV2Frames, sizingFile,
      _this = this;
    this.filepath = filepath;
    openingFile = Q.nfcall(fs.open, filepath, 'r');
    sizingFile = Q.nfcall(fs.stat, filepath);
    context = {
      fd: null,
      fileSize: null,
      position: 0
    };
    parseV2Frames = function(buff) {
      var frame, frames, loadingFrames, readFrame;
      if (_this.version.minor >= 3) {
        frames = Frame.FRAMES;
      } else if (_this.version.minor <= 2) {
        frames = Frame.FRAMES_2_2;
      }
      readFrame = _this.getFrameReader(buff, frames);
      loadingFrames = [];
      while ((frame = readFrame()) !== false) {
        loadingFrames.push(frame);
      }
      return Q.allSettled(loadingFrames).then(function(results) {
        var errors, successes;
        successes = [];
        errors = [];
        results.forEach(function(result) {
          if (result.state === 'fulfilled') {
            return successes.push(result.value);
          } else {
            return errors.push(result.reason);
          }
        });
        errors.forEach(function(err) {
          if (!(err instanceof ID3JunkFrameError)) {
            throw err;
          }
        });
        successes.forEach(function(frame) {
          if (frame instanceof Frame) {
            return _this.add(frame);
          } else if (frame != null) {
            return _this.unknownFrames.push(frame);
          }
        });
        return _this;
      });
    };
    parseV1Frames = function(buff) {
      var frame, frames, name;
      frames = ParseID3v1(buff);
      if (frames == null) {
        throw err;
      }
      _this.version = {
        major: 1,
        minor: 1
      };
      for (name in frames) {
        frame = frames[name];
        _this.add(frame);
      }
      return _this;
    };
    closeFile = function() {
      var closing;
      closing = context.fd ? Q.nfcall(fs.close, context.fd) : true;
      context = null;
      return closing;
    };
    return Q.all([openingFile, sizingFile]).spread(function(fd, stat) {
      context.fd = fd;
      context.fileSize = stat.size;
      return _this.loadHeader(context);
    }).then(function() {
      return _this.fullRead(context, _this.size - 10);
    }).then(parseV2Frames).fail(function(err) {
      switch (false) {
        case !(err instanceof EOFError):
          _this.size = 0;
          throw new ID3NoHeaderError("" + _this.filepath + ": too small (" + context.fileSize + " bytes)");
          break;
        case !(err instanceof ID3NoHeaderError):
        case !(err instanceof ID3UnsupportedVersionError):
          _this.size = 0;
          if (context.fileSize < 128) {
            throw err;
          }
          context.position = context.fileSize - 128;
          return _this.fullRead(context, 128).then(parseV1Frames);
        default:
          throw err;
      }
    }).fin(closeFile).nodeify(callback);
  };

  ID3.prototype.add = function(frame) {
    return this[frame.HashKey] = frame;
  };

  ID3.prototype.loadHeader = function(context) {
    var parseExtendedHeader,
      _this = this;
    parseExtendedHeader = function(data) {
      var extSizeRepr;
      extSizeRepr = (convert(data)).from('latin1');
      if (Frame.FRAMES[extSizeRepr]) {
        _this._flags = _this._flags ^ 0x40;
        _this.extSize = 0;
        context.position -= 4;
      } else if (_this.version.minor >= 4) {
        _this.extSize = BitPaddedInt(extSizeRepr) - 4;
      } else {
        _this.extSize = BitPaddedInt(extSizeRepr, 8);
      }
      _this.extData = new Buffer('');
      if (!_this.extSize) {
        return _this;
      }
      return _this.fullRead(context, _this.extSize).then(function(extData) {
        _this.extData = extData;
        return _this;
      });
    };
    return this.fullRead(context, 10).then(function(data) {
      var id3, offset, sizeRepr, _ref2;
      offset = 0;
      id3 = (convert(data.slice(offset, offset += 3))).from('latin1');
      _this.version = {
        major: 2,
        minor: data.readUInt8(offset++),
        sub: data.readUInt8(offset++)
      };
      _this._flags = data.readUInt8(offset++);
      sizeRepr = (convert(data.slice(offset, offset += 4))).from('latin1');
      _this.size = BitPaddedInt(sizeRepr) + 10;
      if (id3 !== 'ID3') {
        throw new ID3NoHeaderError("" + _this.filepath + " doesn't start with an ID3 tag");
      }
      if ((_ref2 = _this.version.minor) !== 2 && _ref2 !== 3 && _ref2 !== 4) {
        throw new ID3UnsupportedVersionError("" + _this.filepath + " ID3v2." + _this.version.minor + " not supported");
      }
      if (!_this.f_extended) {
        return _this;
      }
      return _this.fullRead(context, 4).then(parseExtendedHeader);
    });
  };

  ID3.prototype.getFrameReader = function(data, frames) {
    var bpi, err, reader,
      _this = this;
    if ((this.version.minor < 4) && this.f_unsynch) {
      try {
        data = unsynch.decode(data);
      } catch (_error) {
        err = _error;
        if (!(err instanceof ValueError)) {
          throw err;
        }
      }
    }
    if (3 <= this.version.minor) {
      bpi = this.determineBPI(data, frames);
      return reader = function() {
        var flags, framedata, header, name, offset, size, tag;
        while (data.length > 0) {
          header = data.slice(0, 10);
          offset = 0;
          try {
            name = (convert(header.slice(offset, offset += 4))).from('latin1');
            size = header.readUInt32BE(offset);
            offset += 4;
            flags = header.readUInt16BE(offset);
          } catch (_error) {
            err = _error;
            return false;
          }
          if ((name.replace(/[\x00]+$/g, '')) === '') {
            return false;
          }
          size = bpi(size);
          framedata = data.slice(10, 10 + size);
          data = data.slice(10 + size);
          if (size === 0) {
            continue;
          }
          tag = frames[name];
          if (!(tag === void 0 || typeof tag === 'string')) {
            return _this.loadFramedata(tag, flags, framedata).fail(function(err) {
              if (err instanceof NotImplementedError) {
                return Buffer.concat(header, framedata);
              }
              throw err;
            });
          } else {
            if (Frame.isValidFrameId(name)) {
              return Buffer.concat(header, framedata);
            }
          }
        }
      };
    } else if (2 <= this.version.minor) {
      return reader = function() {
        var framedata, header, name, offset, size, tag;
        while (data.length > 0) {
          header = data.slice(0, 6);
          offset = 0;
          try {
            name = (convert(header.slice(offset, offset += 3))).from('latin1');
            size = header.slice(offset, offset += 3);
          } catch (_error) {
            err = _error;
            return false;
          }
          size = Buffer.concat([new Buffer('00', 'hex'), size]);
          size = size.readUInt32BE(0);
          if ((name.replace(/[\x00]+$/g, '')) === '') {
            return false;
          }
          framedata = data.slice(6, 6 + size);
          data = data.slice(6 + size);
          if (size === 0) {
            continue;
          }
          tag = frames[name];
          if (!(tag === void 0 || typeof tag === 'string')) {
            return _this.loadFramedata(tag, 0, framedata).fail(function(err) {
              if (err instanceof NotImplementedError) {
                return Buffer.concat(header, framedata);
              }
              throw err;
            });
          } else {
            if (Frame.isValidFrameId(name)) {
              return Buffer.concat(header, framedata);
            }
          }
        }
      };
    }
  };

  ID3.prototype.loadFramedata = function(tag, flags, data) {
    return tag.fromData(tag, this, flags, data);
  };

  ID3.prototype.determineBPI = function(data, frames) {
    var EMPTY, asbpi, asint, bpioff, flags, intoff, name, o, part, size;
    EMPTY = "\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00";
    if (this.version.minor < 4) {
      return function(i) {
        return parseInt(i, 10);
      };
    }
    o = 0;
    asbpi = 0;
    while (o < (data.length - 10)) {
      part = data.slice(o, o + 10);
      if (part === EMPTY) {
        bpioff = -((data.length - o) % 10);
        break;
      }
      name = (convert(part.slice(0, 4))).from('latin1');
      size = part.readUInt32BE(4);
      flags = part.readUInt16BE(8);
      size = BitPaddedInt(size);
      o += 10 + size;
      if (frames[name] != null) {
        asbpi++;
      }
      if (!o < (data.length - 10)) {
        bpioff = o - data.length;
      }
    }
    o = 0;
    asint = 0;
    while (o < (data.length - 10)) {
      part = data.slice(o, o + 10);
      if (part === EMPTY) {
        intoff = -((data.length - o) % 10);
        break;
      }
      name = (convert(part.slice(0, 4))).from('latin1');
      size = part.readUInt32BE(4);
      flags = part.readUInt16BE(8);
      o += 10 + size;
      if (frames[name] != null) {
        asint++;
      }
      if (!o < (data.length - 10)) {
        intoff = o - data.length;
      }
    }
    if ((asint > asbpi) || ((asint === asbpi) && ((bpioff >= 1) && (intoff <= 1)))) {
      return function(i) {
        return parseInt(i, 10);
      };
    }
    return function(i) {
      return BitPaddedInt(i);
    };
  };

  return ID3;

})();

module.exports = ID3;

ParseID3v1 = function(buffer) {
  var album, artist, comment, err, fix, frames, genre, hexString, offset, str, tag, tagByteLength, title, track, year, _ref2;
  hexString = buffer.toString('hex');
  hexString = hexString.slice(hexString.indexOf('544147'));
  if (hexString === -1) {
    return null;
  }
  tagByteLength = Buffer.byteLength(hexString, 'hex');
  if (128 < tagByteLength || tagByteLength < 124) {
    return null;
  }
  buffer = new Buffer(hexString, 'hex');
  try {
    offset = 0;
    tag = (convert(buffer.slice(offset, offset += 3))).from('latin1');
    title = (convert(buffer.slice(offset, offset += 30))).from('latin1');
    artist = (convert(buffer.slice(offset, offset += 30))).from('latin1');
    album = (convert(buffer.slice(offset, offset += 30))).from('latin1');
    year = (convert(buffer.slice(offset, offset += tagByteLength - 124))).from('latin1');
    comment = (convert(buffer.slice(offset, offset += 29))).from('latin1');
    track = buffer.readUInt8(offset++);
    genre = buffer.readUInt8(offset++);
  } catch (_error) {
    err = _error;
    return null;
  }
  if (tag !== 'TAG') {
    return null;
  }
  fix = function(string) {
    return string.split('\u0000')[0].trim();
  };
  _ref2 = (function() {
    var _i, _len, _ref2, _results;
    _ref2 = [title, artist, album, year, comment];
    _results = [];
    for (_i = 0, _len = _ref2.length; _i < _len; _i++) {
      str = _ref2[_i];
      _results.push(fix(str));
    }
    return _results;
  })(), title = _ref2[0], artist = _ref2[1], album = _ref2[2], year = _ref2[3], comment = _ref2[4];
  frames = {};
  if (title) {
    frames["TIT2"] = new Frame.FRAMES.TIT2({
      encoding: 0,
      text: title
    });
  }
  if (artist) {
    frames["TPE1"] = new Frame.FRAMES.TPE1({
      encoding: 0,
      text: [artist]
    });
  }
  if (album) {
    frames["TALB"] = new Frame.FRAMES.TALB({
      encoding: 0,
      text: album
    });
  }
  if (year) {
    frames["TDRC"] = new Frame.FRAMES.TDRC({
      encoding: 0,
      text: year
    });
  }
  if (comment) {
    frames["COMM"] = new Frame.FRAMES.COMM({
      encoding: 0,
      lang: "eng",
      desc: "ID3v1 Comment",
      text: comment
    });
  }
  if (track && (track !== 32 || hexString.slice(-6, -4) === '00')) {
    frames["TRCK"] = new Frame.FRAMES.TRCK({
      encoding: 0,
      text: track.toString()
    });
  }
  if (genre !== 255) {
    frames["TCON"] = new Frame.FRAMES.TCON({
      encoding: 0,
      text: genre.toString()
    });
  }
  return frames;
};
