// Generated by CoffeeScript 1.6.3
var ByteSpec, EncodedNumericPartTextSpec, EncodedNumericTextSpec, EncodedTextSpec, EncodingSpec, ID3TimeStamp, MultiSpec, Spec, StringSpec, TimeStampSpec, UnicodeDecodeError, ValueError, convert, isArray, isString, sprintf, _ref, _ref1, _ref2,
  __hasProp = {}.hasOwnProperty,
  __extends = function(child, parent) { for (var key in parent) { if (__hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },
  __slice = [].slice;

sprintf = require("sprintf-js").sprintf;

convert = require('../text-encodings');

_ref = require('../errors'), ValueError = _ref.ValueError, UnicodeDecodeError = _ref.UnicodeDecodeError;

isString = function(a) {
  return Object.prototype.toString.call(a) === "[object String]";
};

isArray = require('util').isArray;

Spec = (function() {
  function Spec(name) {
    this.name = name;
  }

  return Spec;

})();

ByteSpec = (function(_super) {
  __extends(ByteSpec, _super);

  function ByteSpec(name) {
    if (!(this instanceof ByteSpec)) {
      return (function(func, args, ctor) {
        ctor.prototype = func.prototype;
        var child = new ctor, result = func.apply(child, args);
        return Object(result) === result ? result : child;
      })(ByteSpec, arguments, function(){});
    }
    ByteSpec.__super__.constructor.call(this, name);
  }

  ByteSpec.prototype.read = function(frame, data) {
    return [data.toString('utf8', 0, 1).charCodeAt(0), data.slice(1)];
  };

  ByteSpec.prototype.validate = function(frame, value) {
    return value;
  };

  return ByteSpec;

})(Spec);

EncodingSpec = (function(_super) {
  __extends(EncodingSpec, _super);

  function EncodingSpec(name) {
    if (!(this instanceof EncodingSpec)) {
      return (function(func, args, ctor) {
        ctor.prototype = func.prototype;
        var child = new ctor, result = func.apply(child, args);
        return Object(result) === result ? result : child;
      })(EncodingSpec, arguments, function(){});
    }
    EncodingSpec.__super__.constructor.call(this, name);
  }

  EncodingSpec.prototype.read = function(frame, data) {
    var chr, enc, _ref1;
    _ref1 = EncodingSpec.__super__.read.apply(this, arguments), enc = _ref1[0], data = _ref1[1];
    if (enc < 16) {
      return [enc, data];
    }
    chr = new Buffer(String.fromCharCode(enc), 'utf8');
    return [0, Buffer.concat([chr, data])];
  };

  EncodingSpec.prototype.validate = function(frame, value) {
    if ((0 <= value && value <= 3)) {
      return value;
    }
    if (!value) {
      return null;
    }
    throw new ValueError("Invalid Encoding: " + value);
  };

  return EncodingSpec;

})(ByteSpec);

StringSpec = (function(_super) {
  __extends(StringSpec, _super);

  function StringSpec(name, length) {
    if (!(this instanceof StringSpec)) {
      return (function(func, args, ctor) {
        ctor.prototype = func.prototype;
        var child = new ctor, result = func.apply(child, args);
        return Object(result) === result ? result : child;
      })(StringSpec, arguments, function(){});
    }
    this.len = length;
    StringSpec.__super__.constructor.call(this, name);
  }

  StringSpec.prototype.read = function(frame, data) {
    return [(convert(data.slice(0, this.len))).from('latin1'), data.slice(this.len)];
  };

  StringSpec.prototype.validate = function(frame, value) {
    if (value == null) {
      return null;
    }
    if (isString(value) && value.length === this.len) {
      return value;
    }
    throw new ValueError(sprintf('Invalid StringSpec[%d] data: %s', this.len, value));
  };

  return StringSpec;

})(Spec);

MultiSpec = (function(_super) {
  __extends(MultiSpec, _super);

  function MultiSpec() {
    var name, sep, specs, _i;
    name = arguments[0], specs = 3 <= arguments.length ? __slice.call(arguments, 1, _i = arguments.length - 1) : (_i = 1, []), sep = arguments[_i++];
    if (!(this instanceof MultiSpec)) {
      Array.prototype.unshift.call(arguments, null);
      return new (Function.prototype.bind.apply(MultiSpec, arguments));
    }
    this.specs = specs;
    this.sep = sep;
    MultiSpec.__super__.constructor.call(this, name);
  }

  MultiSpec.prototype.read = function(frame, data) {
    var record, spec, value, values, _i, _len, _ref1, _ref2;
    values = [];
    while (data.length) {
      record = [];
      _ref1 = this.specs;
      for (_i = 0, _len = _ref1.length; _i < _len; _i++) {
        spec = _ref1[_i];
        _ref2 = spec.read(frame, data), value = _ref2[0], data = _ref2[1];
        record.push(value);
      }
      if (this.specs.length !== 1) {
        values.push(record);
      } else {
        values.push(record[0]);
      }
    }
    return [values, data];
  };

  MultiSpec.prototype.validate = function(frame, value) {
    var v;
    if (!value) {
      return [];
    }
    if (this.sep && isString(value)) {
      value = value.split(this.sep);
    }
    if (isArray(value)) {
      if (this.specs.length === 1) {
        return (function() {
          var _i, _len, _results;
          _results = [];
          for (_i = 0, _len = value.length; _i < _len; _i++) {
            v = value[_i];
            _results.push(this.specs[0].validate(frame, v));
          }
          return _results;
        }).call(this);
      }
      throw new ValueError("Invalid MultiSpec data: " + value);
    }
  };

  return MultiSpec;

})(Spec);

EncodedTextSpec = (function(_super) {
  __extends(EncodedTextSpec, _super);

  EncodedTextSpec._encodings = [['latin1', '00'], ['utf16', '0000'], ['utf16be', '0000'], ['utf8', '00']];

  function EncodedTextSpec(name) {
    if (!(this instanceof EncodedTextSpec)) {
      return (function(func, args, ctor) {
        ctor.prototype = func.prototype;
        var child = new ctor, result = func.apply(child, args);
        return Object(result) === result ? result : child;
      })(EncodedTextSpec, arguments, function(){});
    }
    EncodedTextSpec.__super__.constructor.call(this, name);
  }

  EncodedTextSpec.prototype.read = function(frame, data) {
    var encoding, grouping, hexArr, hexStr, offset, ret, stringOffset, term, _ref1, _ref2;
    _ref1 = EncodedTextSpec._encodings[frame.encoding], encoding = _ref1[0], term = _ref1[1];
    hexStr = data.toString('hex');
    grouping = term.length === 2 ? /(.{2})/g : /(.{4})/g;
    hexArr = hexStr.match(grouping);
    ret = '';
    offset = hexArr.indexOf(term);
    if (offset !== -1) {
      stringOffset = offset * term.length;
      _ref2 = [hexStr.slice(0, stringOffset), hexStr.slice(stringOffset + term.length)], data = _ref2[0], ret = _ref2[1];
    }
    if (typeof data === 'string') {
      data = new Buffer(data, 'hex');
    }
    ret = new Buffer(ret, 'hex');
    if (data.length < (term.length / 2)) {
      return ['', ret];
    }
    return [(convert(data)).from(encoding), ret];
  };

  EncodedTextSpec.prototype.validate = function(frame, value) {
    return value;
  };

  return EncodedTextSpec;

})(Spec);

EncodedNumericTextSpec = (function(_super) {
  __extends(EncodedNumericTextSpec, _super);

  function EncodedNumericTextSpec() {
    _ref1 = EncodedNumericTextSpec.__super__.constructor.apply(this, arguments);
    return _ref1;
  }

  return EncodedNumericTextSpec;

})(EncodedTextSpec);

EncodedNumericPartTextSpec = (function(_super) {
  __extends(EncodedNumericPartTextSpec, _super);

  function EncodedNumericPartTextSpec() {
    _ref2 = EncodedNumericPartTextSpec.__super__.constructor.apply(this, arguments);
    return _ref2;
  }

  return EncodedNumericPartTextSpec;

})(EncodedTextSpec);

ID3TimeStamp = (function() {
  var formats, seps, splitre, strictInt;

  formats = ['%04d', '%02d', '%02d', '%02d', '%02d', '%02d'];

  seps = ['-', '-', ' ', ':', ':', 'x'];

  strictInt = /^\-?([0-9]+|Infinity)$/;

  splitre = /[-T:/.]|\s+/;

  function ID3TimeStamp(text) {
    Object.defineProperty(this, 'text', {
      enumerable: true,
      get: function() {
        var idx, part, parts, pieces, _i, _len;
        parts = [this.year, this.month, this.day, this.hour, this.minute, this.second];
        pieces = [];
        for (idx = _i = 0, _len = parts.length; _i < _len; idx = ++_i) {
          part = parts[idx];
          if (part !== null) {
            pieces.push(sprintf(formats[idx], part) + seps[idx]);
          }
        }
        return pieces.join('').slice(0, -1);
      },
      set: function(text) {
        var day, hour, minute, month, second, unit, v, values, year, _ref3, _results;
        _ref3 = (text + ':::::').split(splitre).slice(0, 6), year = _ref3[0], month = _ref3[1], day = _ref3[2], hour = _ref3[3], minute = _ref3[4], second = _ref3[5];
        values = {
          year: year,
          month: month,
          day: day,
          hour: hour,
          minute: minute,
          second: second
        };
        _results = [];
        for (unit in values) {
          v = values[unit];
          v = parseInt(v, 10);
          if (Number.isNaN(v) || !strictInt.test(v)) {
            v = null;
          }
          _results.push(this[unit] = v);
        }
        return _results;
      }
    });
    if (text instanceof ID3TimeStamp) {
      text = text.text;
    }
    this.text = text;
  }

  ID3TimeStamp.prototype.toString = function() {
    return this.text;
  };

  ID3TimeStamp.prototype.valueOf = function() {
    return this.text;
  };

  return ID3TimeStamp;

})();

TimeStampSpec = (function(_super) {
  __extends(TimeStampSpec, _super);

  function TimeStampSpec(name) {
    if (!(this instanceof TimeStampSpec)) {
      return (function(func, args, ctor) {
        ctor.prototype = func.prototype;
        var child = new ctor, result = func.apply(child, args);
        return Object(result) === result ? result : child;
      })(TimeStampSpec, arguments, function(){});
    }
    TimeStampSpec.__super__.constructor.call(this, name);
  }

  TimeStampSpec.prototype.read = function(frame, data) {
    var value, _ref3;
    _ref3 = TimeStampSpec.__super__.read.apply(this, arguments), value = _ref3[0], data = _ref3[1];
    return [this.validate(frame, value), data];
  };

  TimeStampSpec.prototype.validate = function(frame, value) {
    var err;
    try {
      return new ID3TimeStamp(value);
    } catch (_error) {
      err = _error;
      throw new ValueError("Invalid ID3TimeStamp: " + value);
    }
  };

  return TimeStampSpec;

})(EncodedTextSpec);

module.exports = {
  Spec: Spec,
  ByteSpec: ByteSpec,
  EncodingSpec: EncodingSpec,
  StringSpec: StringSpec,
  MultiSpec: MultiSpec,
  EncodedTextSpec: EncodedTextSpec,
  EncodedNumericTextSpec: EncodedNumericTextSpec,
  EncodedNumericPartTextSpec: EncodedNumericPartTextSpec,
  ID3TimeStamp: ID3TimeStamp,
  TimeStampSpec: TimeStampSpec
};
