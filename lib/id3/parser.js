// Generated by CoffeeScript 1.6.3
var BitPaddedInt, EOFError, Frame, ID3JunkFrameError, ID3NoHeaderError, ID3UnsupportedVersionError, NotImplementedError, ParseID3v1, Parser, Q, ValueError, convert, fs, unsynch, _ref, _ref1;

fs = require('fs');

Q = require('q');

unsynch = require('./unsynch');

convert = require('../text-encodings');

BitPaddedInt = require('../BitPaddedInt');

Frame = require('./frame').Frame;

_ref = require('../errors'), ValueError = _ref.ValueError, EOFError = _ref.EOFError, NotImplementedError = _ref.NotImplementedError;

_ref1 = require('./errors'), ID3NoHeaderError = _ref1.ID3NoHeaderError, ID3UnsupportedVersionError = _ref1.ID3UnsupportedVersionError, ID3JunkFrameError = _ref1.ID3JunkFrameError;

Parser = (function() {
  function Parser(tag, context) {
    this.tag = tag;
    this.context = context;
    this;
  }

  Parser.prototype.read = function(size) {
    var fd, fileSize, position, readingFile, _ref2,
      _this = this;
    if (size < 0) {
      throw new ValueError("Requested bytes " + size + " less than zero");
    }
    _ref2 = this.context, fd = _ref2.fd, position = _ref2.position, fileSize = _ref2.fileSize;
    if ((fileSize != null) && size > fileSize) {
      throw new EOFError("Requested " + size + " of " + fileSize + " " + this.filepath);
    }
    readingFile = Q.nfcall(fs.read, fd, new Buffer(size), 0, size, position);
    return readingFile.spread(function(bytesRead, buff) {
      if (bytesRead !== size) {
        throw new EOFError('End of file');
      }
      _this.context.position += bytesRead;
      return buff;
    });
  };

  Parser.prototype.loadHeader = function() {
    var _this = this;
    return this.read(10).then(function(data) {
      var id3, msg, offset, sizeRepr, _ref2;
      offset = 0;
      id3 = (convert(data.slice(offset, offset += 3))).from('latin1');
      _this.tag.version = {
        major: 2,
        minor: data.readUInt8(offset++),
        sub: data.readUInt8(offset++)
      };
      _this.tag._flags = data.readUInt8(offset++);
      sizeRepr = (convert(data.slice(offset, offset += 4))).from('latin1');
      _this.tag.size = BitPaddedInt(sizeRepr) + 10;
      if (id3 !== 'ID3') {
        throw new ID3NoHeaderError("" + _this.tag.filepath + " doesn't start with an ID3 tag");
      }
      if ((_ref2 = _this.tag.version.minor) !== 2 && _ref2 !== 3 && _ref2 !== 4) {
        msg = "" + _this.tag.filepath + " ID3v2." + _this.tag.version.minor + " not supported";
        throw new ID3UnsupportedVersionError(msg);
      }
      if (!_this.tag.f_extended) {
        return _this.tag;
      }
      return _this.loadExtendedHeader();
    });
  };

  Parser.prototype.loadExtendedHeader = function() {
    var _this = this;
    return this.read(4).then(function(data) {
      var extSizeRepr;
      extSizeRepr = (convert(data)).from('latin1');
      if (Frame.FRAMES[extSizeRepr]) {
        _this.tag._flags = _this.tag._flags ^ 0x40;
        _this.tag.extSize = 0;
        _this.context.position -= 4;
      } else if (_this.tag.version.minor >= 4) {
        _this.tag.extSize = BitPaddedInt(extSizeRepr) - 4;
      } else {
        _this.tag.extSize = BitPaddedInt(extSizeRepr, 8);
      }
      _this.tag.extData = new Buffer('');
      if (!_this.tag.extSize) {
        return _this.tag;
      }
      return _this.read(_this.tag.extSize).then(function(data) {
        _this.tag.extData = data;
        return _this.tag;
      });
    });
  };

  Parser.prototype.readV2Frames = function() {
    var _this = this;
    return this.read(this.tag.size - 10).then(function(buff) {
      var frame, frames, loadingFrames, readFrame;
      if (_this.tag.version.minor >= 3) {
        frames = Frame.FRAMES;
      } else if (_this.tag.version.minor <= 2) {
        frames = Frame.FRAMES_2_2;
      }
      readFrame = _this.getFrameReader(buff, frames);
      loadingFrames = [];
      while ((frame = readFrame())) {
        loadingFrames.push(frame);
      }
      return Q.allSettled(loadingFrames).then(function(resolved) {
        var err, errors, promise, _i, _j, _k, _len, _len1, _len2;
        frames = [];
        errors = [];
        for (_i = 0, _len = resolved.length; _i < _len; _i++) {
          promise = resolved[_i];
          if (promise.state === 'fulfilled') {
            frames.push(promise.value);
          } else {
            errors.push(promise.reason);
          }
        }
        for (_j = 0, _len1 = errors.length; _j < _len1; _j++) {
          err = errors[_j];
          if (!(err instanceof ID3JunkFrameError)) {
            throw err;
          }
        }
        for (_k = 0, _len2 = frames.length; _k < _len2; _k++) {
          frame = frames[_k];
          if (frame instanceof Frame) {
            _this.tag.add(frame);
          } else if (frame != null) {
            _this.tag.unknownFrames.push(frame);
          }
        }
        return _this.tag;
      });
    });
  };

  Parser.prototype.readV1Frames = function() {
    var _this = this;
    this.context.position = this.context.fileSize - 128;
    return this.read(128).then(function(buff) {
      var frame, frames, name;
      frames = ParseID3v1(buff);
      if (frames == null) {
        return null;
      }
      _this.tag.version = {
        major: 1,
        minor: 1
      };
      for (name in frames) {
        frame = frames[name];
        _this.tag.add(frame);
      }
      return _this.tag;
    });
  };

  Parser.prototype.determineBPI = function(data, frames) {
    var EMPTY, asbpi, asint, bpioff, flags, intoff, name, o, part, size;
    EMPTY = "\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00";
    if (this.tag.version.minor < 4) {
      return function(i) {
        return parseInt(i, 10);
      };
    }
    o = 0;
    asbpi = 0;
    while (o < (data.length - 10)) {
      part = data.slice(o, o + 10);
      if (part === EMPTY) {
        bpioff = -((data.length - o) % 10);
        break;
      }
      name = (convert(part.slice(0, 4))).from('latin1');
      size = part.readUInt32BE(4);
      flags = part.readUInt16BE(8);
      size = BitPaddedInt(size);
      o += 10 + size;
      if (frames[name] != null) {
        asbpi++;
      }
      if (!o < (data.length - 10)) {
        bpioff = o - data.length;
      }
    }
    o = 0;
    asint = 0;
    while (o < (data.length - 10)) {
      part = data.slice(o, o + 10);
      if (part === EMPTY) {
        intoff = -((data.length - o) % 10);
        break;
      }
      name = (convert(part.slice(0, 4))).from('latin1');
      size = part.readUInt32BE(4);
      flags = part.readUInt16BE(8);
      o += 10 + size;
      if (frames[name] != null) {
        asint++;
      }
      if (!o < (data.length - 10)) {
        intoff = o - data.length;
      }
    }
    if ((asint > asbpi) || ((asint === asbpi) && ((bpioff >= 1) && (intoff <= 1)))) {
      return function(i) {
        return parseInt(i, 10);
      };
    }
    return function(i) {
      return BitPaddedInt(i);
    };
  };

  Parser.prototype.getFrameReader = function(data, frames) {
    var bpi, err, reader,
      _this = this;
    if ((this.tag.version.minor < 4) && this.tag.f_unsynch) {
      try {
        data = unsynch.decode(data);
      } catch (_error) {
        err = _error;
        if (!(err instanceof ValueError)) {
          throw err;
        }
      }
    }
    if (3 <= this.tag.version.minor) {
      bpi = this.determineBPI(data, frames);
      return reader = function() {
        var flags, frame, frameEnd, framedata, header, name, offset, size;
        while (data.length > 0) {
          header = data.slice(0, 10);
          offset = 0;
          try {
            name = (convert(header.slice(offset, offset += 4))).from('latin1');
            size = header.readUInt32BE(offset);
            offset += 4;
            flags = header.readUInt16BE(offset);
          } catch (_error) {
            err = _error;
            return false;
          }
          if ((name.replace(/[\x00]+$/g, '')) === '') {
            return false;
          }
          size = bpi(size);
          frameEnd = 10 + size;
          if (frameEnd > data.length) {
            frameEnd = data.length - 1;
          }
          framedata = data.slice(10, frameEnd);
          data = data.slice(frameEnd);
          if (size === 0) {
            continue;
          }
          frame = frames[name];
          if (!(frame === void 0 || typeof frame === 'string')) {
            return _this.tag.loadFramedata(frame, flags, framedata).fail(function(err) {
              if (err instanceof NotImplementedError) {
                return Buffer.concat([header, framedata]);
              }
              throw err;
            });
          } else {
            if (Frame.isValidFrameId(name)) {
              return Buffer.concat([header, framedata]);
            }
          }
        }
      };
    } else if (2 <= this.tag.version.minor) {
      return reader = function() {
        var frame, frameEnd, framedata, header, name, offset, size;
        while (data.length > 0) {
          header = data.slice(0, 6);
          offset = 0;
          try {
            name = (convert(header.slice(offset, offset += 3))).from('latin1');
            size = header.slice(offset, offset += 3);
            size = Buffer.concat([new Buffer('00', 'hex'), size]);
            size = size.readUInt32BE(0);
          } catch (_error) {
            err = _error;
            return false;
          }
          if ((name.replace(/[\x00]+$/g, '')) === '') {
            return false;
          }
          frameEnd = 6 + size;
          if (frameEnd > data.length) {
            frameEnd = data.length - 1;
          }
          framedata = data.slice(6, frameEnd);
          data = data.slice(frameEnd);
          if (size === 0) {
            continue;
          }
          frame = frames[name];
          if (!(frame === void 0 || typeof frame === 'string')) {
            return _this.tag.loadFramedata(frame, 0, framedata).fail(function(err) {
              if (err instanceof NotImplementedError) {
                return Buffer.concat([header, framedata]);
              }
              throw err;
            });
          } else {
            if (Frame.isValidFrameId(name)) {
              return Buffer.concat([header, framedata]);
            }
          }
        }
      };
    }
  };

  return Parser;

})();

ParseID3v1 = function(buffer) {
  var album, artist, comment, err, fix, frames, genre, hexString, offset, str, tag, tagByteLength, title, track, year, _ref2;
  hexString = buffer.toString('hex');
  hexString = hexString.slice(hexString.indexOf('544147'));
  if (hexString === -1) {
    return null;
  }
  tagByteLength = Buffer.byteLength(hexString, 'hex');
  if (128 < tagByteLength || tagByteLength < 124) {
    return null;
  }
  buffer = new Buffer(hexString, 'hex');
  try {
    offset = 0;
    tag = (convert(buffer.slice(offset, offset += 3))).from('latin1');
    title = (convert(buffer.slice(offset, offset += 30))).from('latin1');
    artist = (convert(buffer.slice(offset, offset += 30))).from('latin1');
    album = (convert(buffer.slice(offset, offset += 30))).from('latin1');
    year = (convert(buffer.slice(offset, offset += tagByteLength - 124))).from('latin1');
    comment = (convert(buffer.slice(offset, offset += 29))).from('latin1');
    track = buffer.readUInt8(offset++);
    genre = buffer.readUInt8(offset++);
  } catch (_error) {
    err = _error;
    return null;
  }
  if (tag !== 'TAG') {
    return null;
  }
  fix = function(string) {
    return string.split('\u0000')[0].trim();
  };
  _ref2 = (function() {
    var _i, _len, _ref2, _results;
    _ref2 = [title, artist, album, year, comment];
    _results = [];
    for (_i = 0, _len = _ref2.length; _i < _len; _i++) {
      str = _ref2[_i];
      _results.push(fix(str));
    }
    return _results;
  })(), title = _ref2[0], artist = _ref2[1], album = _ref2[2], year = _ref2[3], comment = _ref2[4];
  frames = {};
  if (title) {
    frames["TIT2"] = new Frame.FRAMES.TIT2({
      encoding: 0,
      text: title
    });
  }
  if (artist) {
    frames["TPE1"] = new Frame.FRAMES.TPE1({
      encoding: 0,
      text: [artist]
    });
  }
  if (album) {
    frames["TALB"] = new Frame.FRAMES.TALB({
      encoding: 0,
      text: album
    });
  }
  if (year) {
    frames["TDRC"] = new Frame.FRAMES.TDRC({
      encoding: 0,
      text: year
    });
  }
  if (comment) {
    frames["COMM"] = new Frame.FRAMES.COMM({
      encoding: 0,
      lang: "eng",
      desc: "ID3v1 Comment",
      text: comment
    });
  }
  if (track && (track !== 32 || hexString.slice(-6, -4) === '00')) {
    frames["TRCK"] = new Frame.FRAMES.TRCK({
      encoding: 0,
      text: track.toString()
    });
  }
  if (genre !== 255) {
    frames["TCON"] = new Frame.FRAMES.TCON({
      encoding: 0,
      text: genre.toString()
    });
  }
  return frames;
};

module.exports = Parser;
