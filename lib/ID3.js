// Generated by CoffeeScript 1.6.3
var BaseError, BitPaddedInt, EOFError, Frame, ID3, ID3NoHeaderError, ID3UnsupportedVersionError, ParseID3v1, convert, fs, sprintf, unsynch, _, _ref, _ref1,
  __hasProp = {}.hasOwnProperty,
  __extends = function(child, parent) { for (var key in parent) { if (__hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; };

fs = require('fs');

_ = require('underscore');

sprintf = require("sprintf-js").sprintf;

convert = require('./text-encodings');

unsynch = require('./unsynch');

BitPaddedInt = require('./BitPaddedInt');

Frame = require('./Frame');

BaseError = require('./errors.js').BaseError;

EOFError = require('./errors.js').EOFError;

ID3NoHeaderError = (function(_super) {
  __extends(ID3NoHeaderError, _super);

  function ID3NoHeaderError() {
    _ref = ID3NoHeaderError.__super__.constructor.apply(this, arguments);
    return _ref;
  }

  return ID3NoHeaderError;

})(BaseError);

ID3UnsupportedVersionError = (function(_super) {
  __extends(ID3UnsupportedVersionError, _super);

  function ID3UnsupportedVersionError() {
    _ref1 = ID3UnsupportedVersionError.__super__.constructor.apply(this, arguments);
    return _ref1;
  }

  return ID3UnsupportedVersionError;

})(BaseError);

ID3 = (function() {
  function ID3(filepath) {
    Object.defineProperty(this, 'filepath', {
      writable: true,
      value: filepath || null
    });
    Object.defineProperty(this, 'size', {
      writable: true,
      value: 0
    });
    Object.defineProperty(this, 'unknownFrames', {
      writable: false,
      value: []
    });
    Object.defineProperty(this, 'version', {
      writable: true,
      value: {
        major: 2,
        minor: 4,
        sub: 0
      }
    });
    Object.defineProperty(this, '_fd', {
      writable: true,
      value: null
    });
    Object.defineProperty(this, '_fileSize', {
      writable: true,
      value: null
    });
    Object.defineProperty(this, '_readBytes', {
      writable: true,
      value: 0
    });
    Object.defineProperty(this, '_extSize', {
      writable: true,
      value: null
    });
    Object.defineProperty(this, '_extData', {
      writable: true,
      value: null
    });
    Object.defineProperty(this, '_flags', {
      writable: true,
      value: 0
    });
    Object.defineProperty(this, 'f_unsynch', {
      get: function() {
        return (this._flags & 0x80) !== 0;
      }
    });
    Object.defineProperty(this, 'f_extended', {
      get: function() {
        return (this._flags & 0x40) !== 0;
      }
    });
    Object.defineProperty(this, 'f_experimental', {
      get: function() {
        return (this._flags & 0x20) !== 0;
      }
    });
    Object.defineProperty(this, 'f_footer', {
      get: function() {
        return (this._flags & 0x10) !== 0;
      }
    });
    if (filepath != null) {
      this.load(filepath);
    }
  }

  ID3.prototype.fullRead = function(size) {
    var buff, bytesRead;
    if (size < 0) {
      throw new Error("Requested bytes " + size + " less than zero");
    }
    if ((this._fileSize != null) && size > this._fileSize) {
      throw new EOFError("Requested " + size + " of " + this._fileSize + " " + this.filepath);
    }
    buff = new Buffer(size);
    bytesRead = fs.readSync(this._fd, buff, 0, size, this._readBytes);
    if (bytesRead !== size) {
      throw new EOFError('End of file');
    }
    this._readBytes += bytesRead;
    return buff;
  };

  ID3.prototype.load = function(filepath) {
    var data, err, frame, frames, headerLoaded, name, readFrame, _results;
    this.filepath = filepath;
    this._fd = fs.openSync(filepath, 'r');
    this._fileSize = fs.statSync(filepath).size;
    try {
      headerLoaded = false;
      try {
        this.loadHeader();
        return headerLoaded = true;
      } catch (_error) {
        err = _error;
        if (err instanceof EOFError) {
          this.size = 0;
          throw new ID3NoHeaderError("" + this.filepath + ": too small (" + this._fileSize + " bytes)");
        } else if (err instanceof ID3NoHeaderError || err instanceof ID3UnsupportedVersionError) {
          this.size = 0;
          if (this._fileSize < 128) {
            throw err;
          }
          this._readBytes = this._fileSize - 128;
          frames = ParseID3v1(this.fullRead(128));
          if (frames == null) {
            throw err;
          }
          this.version = {
            major: 1,
            minor: 1
          };
          _results = [];
          for (name in frames) {
            frame = frames[name];
            _results.push(this.add(frame));
          }
          return _results;
        }
      } finally {
        if (headerLoaded) {
          if (this.version.minor >= 3) {
            frames = Frame.FRAMES;
          } else if (this.version.minor <= 2) {
            frames = Frame.FRAMES_2_2;
          }
          data = this.fullRead(this.size - 10);
          readFrame = this.getFrameReader(data, frames);
          frame = false;
          while ((frame = readFrame()) !== false) {
            if (frame instanceof Frame) {
              this.add(frame);
            } else if (frame != null) {
              this.unknownFrames.push(frame);
            }
          }
        }
      }
    } finally {
      fs.closeSync(this._fd);
      this._fd = null;
      this._fileSize = null;
    }
  };

  ID3.prototype.add = function(frame) {
    return this[frame.HashKey] = frame;
  };

  ID3.prototype.loadHeader = function() {
    var data, extSizeRepr, id3, offset, sizeRepr, _ref2;
    data = this.fullRead(10);
    offset = 0;
    id3 = (convert(data.slice(offset, offset += 3))).from('latin1');
    this.version = {
      major: 2,
      minor: data.readUInt8(offset++),
      sub: data.readUInt8(offset++)
    };
    this._flags = data.readUInt8(offset++);
    sizeRepr = (convert(data.slice(offset, offset += 4))).from('latin1');
    this.size = BitPaddedInt(sizeRepr) + 10;
    if (id3 !== 'ID3') {
      throw new ID3NoHeaderError("" + this.filepath + " doesn't start with an ID3 tag");
    }
    if ((_ref2 = this.version.minor) !== 2 && _ref2 !== 3 && _ref2 !== 4) {
      throw new ID3UnsupportedVersionError("" + this.filepath + " ID3v2." + this.version.minor + " not supported");
    }
    if (this.f_extended) {
      data = this.fullRead(4);
      extSizeRepr = (convert(data)).from('latin1');
      if (Frame.FRAMES[extSizeRepr]) {
        this._flags = this._flags ^ 0x40;
        this._extSize = 0;
        this._readBytes -= 4;
      } else if (this.version.minor >= 4) {
        this._extSize = BitPaddedInt(extSizeRepr) - 4;
      } else {
        this._extSize = BitPaddedInt(extSizeRepr, 8);
      }
      this._extData = '';
      if (this._extSize) {
        data = this.fullRead(this._extSize);
        return this._extData = data.toString('hex');
      }
    }
  };

  ID3.prototype.getFrameReader = function(data, frames) {
    var bpi, err, reader,
      _this = this;
    if ((this.version.minor < 4) && this.f_unsynch) {
      try {
        data = unsynch.decode(data);
      } catch (_error) {
        err = _error;
      }
    }
    if (3 <= this.version.minor) {
      bpi = this.determineBPI(data, frames);
      return reader = function() {
        var flags, framedata, header, name, offset, size, tag;
        while (true) {
          try {
            header = data.slice(0, 10);
            offset = 0;
            name = (convert(header.slice(offset, offset += 4))).from('latin1');
            size = header.readUInt32BE(offset);
            offset += 4;
            flags = header.readUInt16BE(offset);
          } catch (_error) {
            err = _error;
            console.log(_this.filepath);
            console.log(err.stack, '\n');
            return false;
          }
          if ((name.replace(/[\x00]+$/g, '')) === '') {
            return false;
          }
          size = bpi(size);
          framedata = data.slice(10, 10 + size);
          data = data.slice(10 + size);
          if (!(size === 0)) {
            break;
          }
        }
        tag = frames[name];
        if (tag === void 0 || typeof tag === 'string') {
          if (Frame.isValidFrameId(name)) {
            return header + framedata;
          }
        } else {
          try {
            return _this.loadFramedata(tag, flags, framedata);
          } catch (_error) {
            err = _error;
            console.log(_this.filepath);
            return console.log(err.stack, '\n');
          }
        }
      };
    } else if (2 <= this.version.minor) {
      return reader = function() {
        var framedata, header, name, offset, size, tag;
        while (true) {
          try {
            header = data.slice(0, 6);
            offset = 0;
            name = (convert(header.slice(offset, offset += 3))).from('latin1');
            size = header.slice(offset, offset += 3);
          } catch (_error) {
            err = _error;
            console.log(_this.filepath);
            console.log(err.stack, '\n');
            return false;
          }
          size = Buffer.concat([new Buffer('00', 'hex'), size]);
          size = size.readUInt32BE(0);
          if ((name.replace(/[\x00]+$/g, '')) === '') {
            return false;
          }
          framedata = data.slice(6, 6 + size);
          data = data.slice(6 + size);
          if (!(size === 0)) {
            break;
          }
        }
        tag = frames[name];
        if (tag === void 0 || typeof tag === 'string') {
          if (Frame.isValidFrameId(name)) {
            return header + framedata;
          }
        } else {
          try {
            return _this.loadFramedata(tag, 0, framedata);
          } catch (_error) {
            err = _error;
            console.log(_this.filepath);
            return console.log(err.stack, '\n');
          }
        }
      };
    }
  };

  ID3.prototype.loadFramedata = function(tag, flags, data) {
    return tag.fromData(tag, this, flags, data);
  };

  ID3.prototype.determineBPI = function(data, frames) {
    var EMPTY, asbpi, asint, bpioff, flags, intoff, name, o, part, size;
    EMPTY = "\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00";
    if (this.version.minor < 4) {
      return function(i) {
        return parseInt(i, 10);
      };
    }
    o = 0;
    asbpi = 0;
    while (o < (data.length - 10)) {
      part = data.slice(o, o + 10);
      if (part === EMPTY) {
        bpioff = -((data.length - o) % 10);
        break;
      }
      name = (convert(part.slice(0, 4))).from('latin1');
      size = part.readUInt32BE(4);
      flags = part.readUInt16BE(8);
      size = BitPaddedInt(size);
      o += 10 + size;
      if (frames[name] != null) {
        asbpi++;
      }
      if (!o < (data.length - 10)) {
        bpioff = o - data.length;
      }
    }
    o = 0;
    asint = 0;
    while (o < (data.length - 10)) {
      part = data.slice(o, o + 10);
      if (part === EMPTY) {
        intoff = -((data.length - o) % 10);
        break;
      }
      name = (convert(part.slice(0, 4))).from('latin1');
      size = part.readUInt32BE(4);
      flags = part.readUInt16BE(8);
      o += 10 + size;
      if (frames[name] != null) {
        asint++;
      }
      if (!o < (data.length - 10)) {
        intoff = o - data.length;
      }
    }
    if ((asint > asbpi) || ((asint === asbpi) && ((bpioff >= 1) && (intoff <= 1)))) {
      return function(i) {
        return parseInt(i, 10);
      };
    }
    return function(i) {
      return BitPaddedInt(i);
    };
  };

  return ID3;

})();

module.exports = ID3;

ParseID3v1 = function(buffer) {
  var album, artist, comment, err, fix, frames, genre, hexString, offset, str, tag, tagByteLength, title, track, year, _ref2;
  hexString = buffer.toString('hex');
  hexString = hexString.slice(hexString.indexOf('544147'));
  if (hexString === -1) {
    return null;
  }
  tagByteLength = Buffer.byteLength(hexString, 'hex');
  if (128 < tagByteLength || tagByteLength < 124) {
    return null;
  }
  buffer = new Buffer(hexString, 'hex');
  try {
    offset = 0;
    tag = (convert(buffer.slice(offset, offset += 3))).from('latin1');
    title = (convert(buffer.slice(offset, offset += 30))).from('latin1');
    artist = (convert(buffer.slice(offset, offset += 30))).from('latin1');
    album = (convert(buffer.slice(offset, offset += 30))).from('latin1');
    year = (convert(buffer.slice(offset, offset += tagByteLength - 124))).from('latin1');
    comment = (convert(buffer.slice(offset, offset += 29))).from('latin1');
    track = buffer.readUInt8(offset++);
    genre = buffer.readUInt8(offset++);
  } catch (_error) {
    err = _error;
    return null;
  }
  if (tag !== 'TAG') {
    return null;
  }
  fix = function(string) {
    return string.split('\u0000')[0].trim();
  };
  _ref2 = (function() {
    var _i, _len, _ref2, _results;
    _ref2 = [title, artist, album, year, comment];
    _results = [];
    for (_i = 0, _len = _ref2.length; _i < _len; _i++) {
      str = _ref2[_i];
      _results.push(fix(str));
    }
    return _results;
  })(), title = _ref2[0], artist = _ref2[1], album = _ref2[2], year = _ref2[3], comment = _ref2[4];
  frames = {};
  if (title) {
    frames["TIT2"] = new Frame.FRAMES.TIT2({
      encoding: 0,
      text: title
    });
  }
  if (artist) {
    frames["TPE1"] = new Frame.FRAMES.TPE1({
      encoding: 0,
      text: [artist]
    });
  }
  if (album) {
    frames["TALB"] = new Frame.FRAMES.TALB({
      encoding: 0,
      text: album
    });
  }
  if (year) {
    frames["TDRC"] = new Frame.FRAMES.TDRC({
      encoding: 0,
      text: year
    });
  }
  if (comment) {
    frames["COMM"] = new Frame.FRAMES.COMM({
      encoding: 0,
      lang: "eng",
      desc: "ID3v1 Comment",
      text: comment
    });
  }
  if (track && (track !== 32 || hexString.slice(-6, -4) === '00')) {
    frames["TRCK"] = new Frame.FRAMES.TRCK({
      encoding: 0,
      text: track.toString()
    });
  }
  return frames;
};
