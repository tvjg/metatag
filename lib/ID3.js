// Generated by CoffeeScript 1.3.3
var $FRAMES, BaseError, BitPaddedInt, ByteSpec, EOFError, EncodedNumericTextSpec, EncodedTextSpec, EncodingSpec, FRAMES, FRAMES_2_2, Frame, ID3, ID3NoHeaderError, ID3UnsupportedVersionError, Iconv, MultiSpec, NumericTextFrame, Spec, TALB, TBPM, TCMP, TCOM, TCOP, TDAT, TIME, TIT1, TIT2, TIT3, TPE1, TPE2, TPE3, TPE4, TYER, TextFrame, cls, convertToString, fromLatin1ToString, fromUTF16BEToString, fromUTF16ToString, fromUTF8ToString, fs, latin1ToUTF8, utf16, utf16be, _, _i, _len,
  __hasProp = {}.hasOwnProperty,
  __extends = function(child, parent) { for (var key in parent) { if (__hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },
  __slice = [].slice;

fs = require('fs');

_ = require('underscore');

Iconv = require('iconv').Iconv;

BitPaddedInt = require('./BitPaddedInt.js');

BaseError = require('./errors.js').BaseError;

EOFError = require('./errors.js').EOFError;

ID3NoHeaderError = (function(_super) {

  __extends(ID3NoHeaderError, _super);

  function ID3NoHeaderError() {
    return ID3NoHeaderError.__super__.constructor.apply(this, arguments);
  }

  return ID3NoHeaderError;

})(BaseError);

ID3UnsupportedVersionError = (function(_super) {

  __extends(ID3UnsupportedVersionError, _super);

  function ID3UnsupportedVersionError() {
    return ID3UnsupportedVersionError.__super__.constructor.apply(this, arguments);
  }

  return ID3UnsupportedVersionError;

})(BaseError);

latin1ToUTF8 = new Iconv('ISO-8859-1', 'UTF-8');

utf16 = new Iconv('UTF-16', 'UTF-8');

utf16be = new Iconv('UTF-16BE', 'UTF-8');

convertToString = function(iconv) {
  return function(buffer) {
    return (iconv.convert(buffer)).toString();
  };
};

fromLatin1ToString = convertToString(latin1ToUTF8);

fromUTF16ToString = convertToString(utf16);

fromUTF16BEToString = convertToString(utf16be);

fromUTF8ToString = function(buff) {
  return buff.toString();
};

ID3 = (function() {

  function ID3(filepath) {
    this.__readbytes = 0;
    this.unknownFrames = [];
    if (filepath != null) {
      this.load(filepath);
    }
  }

  ID3.prototype.fullRead = function(size) {
    var buff, bytesRead;
    if (size < 0) {
      throw new Error("Requested bytes " + size + " less than zero");
    }
    if (size > this.__filesize) {
      throw new EOFError("Requested " + size + " of " + this.__filesize + " " + this.filepath);
    }
    buff = new Buffer(size);
    bytesRead = fs.readSync(this.__fileobj, buff, 0, size, this.__readbytes);
    if (bytesRead !== size) {
      throw new EOFError('End of file');
    }
    this.__readbytes += bytesRead;
    return buff;
  };

  ID3.prototype.load = function(filepath) {
    var data, frame, frames, headerLoaded, readFrame;
    this.filepath = filepath;
    this.__fileobj = fs.openSync(filepath, 'r');
    this.__filesize = fs.statSync(filepath).size;
    try {
      headerLoaded = false;
      try {
        this.loadHeader();
        return headerLoaded = true;
      } catch (e) {
        if (e instanceof EOFError) {
          this.size = 0;
          throw new ID3NoHeaderError("" + this.filepath + ": too small (" + this.__filesize + " bytes)");
        }
        return console.log(e);
      } finally {
        if (headerLoaded) {
          if (this.version.majorRev >= 3) {
            frames = FRAMES;
          } else if (this.version.majorRev <= 2) {
            frames = FRAMES_2_2;
          }
          data = this.fullRead(this.size - 10);
          readFrame = this.getFrameReader(data, frames);
          frame = false;
          while ((frame = readFrame()) !== false) {
            if (frame instanceof Frame) {
              this.add(frame);
            } else if (frame != null) {
              this.unknownFrames.push(frame);
            }
          }
        }
      }
    } finally {
      fs.closeSync(this.__fileobj);
      this.__fileobj = null;
      this.__filesize = null;
    }
  };

  ID3.prototype.add = function(frame) {
    return this[frame] = frame;
  };

  ID3.prototype.loadHeader = function() {
    var data, extSizeRepr, flags, id3, offset, sizeRepr, _ref;
    data = this.fullRead(10);
    offset = 0;
    id3 = fromLatin1ToString(data.slice(offset, offset += 3));
    this.version = {
      majorRev: data.readUInt8(offset++),
      minorRev: data.readUInt8(offset++)
    };
    flags = data.readUInt8(offset++);
    this.f_unsynch = (flags & 0x80) !== 0;
    this.f_extended = (flags & 0x40) !== 0;
    this.f_experimental = (flags & 0x20) !== 0;
    this.f_footer = (flags & 0x10) !== 0;
    sizeRepr = fromLatin1ToString(data.slice(offset, offset += 4));
    this.size = BitPaddedInt(sizeRepr) + 10;
    if (id3 !== 'ID3') {
      throw new ID3NoHeaderError("" + this.filepath + " doesn't start with an ID3 tag");
    }
    if ((_ref = this.version.majorRev) !== 2 && _ref !== 3 && _ref !== 4) {
      throw new ID3UnsupportedVersionError("" + this.filepath + " ID3v2." + this.version.majorRev + " not supported");
    }
    if (this.f_extended) {
      data = this.fullRead(4);
      extSizeRepr = fromLatin1ToString(data);
      if (_.include(FRAMES, extSizeRepr)) {
        this.f_extended = false;
        this.__extsize = 0;
        this.__readbytes -= 4;
      } else if (this.version.majorRev >= 4) {
        this.__extsize = BitPaddedInt(extSizeRepr) - 4;
      } else {
        this.__extsize = BitPaddedInt(extSizeRepr, 8);
      }
      this.__extdata = '';
      if (this.__extsize) {
        data = this.fullRead(this.__extsize);
        return this.__extdata = data.toString('hex');
      }
    }
  };

  ID3.prototype.getFrameReader = function(data, frames) {
    var bpi, header, name, offset, reader, size,
      _this = this;
    if (3 <= this.version.majorRev) {
      bpi = this.determineBPI(data, frames);
      return reader = function() {
        var flags, framedata, header, name, offset, size, tag;
        while (true) {
          try {
            header = data.slice(0, 10);
            offset = 0;
            name = fromLatin1ToString(header.slice(offset, offset += 4));
            size = header.readUInt32BE(offset);
            offset += 4;
            flags = header.readUInt16BE(offset);
          } catch (err) {
            console.log(err);
            return false;
          }
          if ((name.replace(/[\x00]+$/g, '')) === '') {
            return false;
          }
          size = bpi(size);
          framedata = data.slice(10, 10 + size);
          data = data.slice(10 + size);
          if (!(size === 0)) {
            break;
          }
        }
        tag = frames[name];
        if (tag === void 0 || typeof tag === 'string') {
          if (Frame.isValidFrameId(name)) {
            return header + framedata;
          }
        } else {
          try {
            return _this.loadFramedata(tag, flags, framedata);
          } catch (err) {
            return console.log(err);
          }
        }
      };
    } else if (2 <= this.version.majorRev) {
      while (data.length) {
        try {
          header = data.slice(0, 6);
          offset = 0;
          name = fromLatin1ToString(header.slice(offset, offset += 3));
          size = fromLatin1ToString(header.slice(offset, offset += 3));
        } catch (err) {
          console.log(err);
          return false;
        }
        if ((name.replace(/[\x00]+$/g, '')) === '') {
          return false;
        }
      }
    }
  };

  ID3.prototype.loadFramedata = function(tag, flags, data) {
    return tag.fromData(tag, this, flags, data);
  };

  ID3.prototype.determineBPI = function(data, frames) {
    var EMPTY, asbpi, asint, bpioff, flags, intoff, name, o, part, size;
    EMPTY = "\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00";
    if (this.version.majorRev < 4) {
      return function(i) {
        return parseInt(i, 10);
      };
    }
    o = 0;
    asbpi = 0;
    while (o < (data.length - 10)) {
      part = data.slice(o, o + 10);
      if (part === EMPTY) {
        bpioff = -((data.length - o) % 10);
        break;
      }
      name = fromLatin1ToString(part.slice(0, 4));
      size = part.readUInt32BE(4);
      flags = part.readUInt16BE(8);
      size = BitPaddedInt(size);
      o += 10 + size;
      if (frames[name] != null) {
        asbpi++;
      }
      if (!o < (data.length - 10)) {
        bpioff = o - data.length;
      }
    }
    o = 0;
    asint = 0;
    while (o < (data.length - 10)) {
      part = data.slice(o, o + 10);
      if (part === EMPTY) {
        intoff = -((data.length - o) % 10);
        break;
      }
      name = fromLatin1ToString(part.slice(0, 4));
      size = part.readUInt32BE(4);
      flags = part.readUInt16BE(8);
      o += 10 + size;
      if (frames[name] != null) {
        asint++;
      }
      if (!o < (data.length - 10)) {
        intoff = o - data.length;
      }
    }
    if ((asint > asbpi) || ((asint === asbpi) && ((bpioff >= 1) && (intoff <= 1)))) {
      return function(i) {
        return parseInt(i, 10);
      };
    }
    return function(i) {
      return BitPaddedInt(i);
    };
  };

  return ID3;

})();

module.exports = ID3;

Frame = (function() {

  function Frame(data) {
    var odata, spec, value, _i, _len, _ref, _ref1;
    odata = data;
    _ref = this.framespec;
    for (_i = 0, _len = _ref.length; _i < _len; _i++) {
      spec = _ref[_i];
      if (!(data.length > 0)) {
        throw new Error('ID3JunkFrameError');
      }
      _ref1 = spec.read(this, data), value = _ref1[0], data = _ref1[1];
      this[spec.name] = value;
    }
  }

  Frame.prototype.toString = function() {
    return this.constructor.name;
  };

  return Frame;

})();

Frame.toString = function() {
  return this.name;
};

Frame.isValidFrameId = function(frameId) {
  var char, i, isAlphaNumeric, lowerBound, lowerBound1, upperBound, upperBound1, _i, _ref;
  upperBound = 'Z'.charCodeAt(0);
  lowerBound = 'A'.charCodeAt(0);
  upperBound1 = '9'.charCodeAt(0);
  lowerBound1 = '0'.charCodeAt(0);
  isAlphaNumeric = true;
  for (i = _i = 0, _ref = frameId.length; 0 <= _ref ? _i <= _ref : _i >= _ref; i = 0 <= _ref ? ++_i : --_i) {
    char = frameId.charCodeAt(i);
    if (char <= upperBound && char >= lowerBound) {
      continue;
    } else if (char <= upperBound1 && char >= lowerBound1) {
      continue;
    } else {
      isAlphaNumeric = false;
    }
  }
  return isAlphaNumeric;
};

Frame.fromData = function(cls, id3, tflags, data) {
  var frame;
  if (4 <= id3.version.majorRev) {
    true;
  } else if (3 <= id3.version.majorRev) {
    true;
  }
  frame = new cls(data);
  return frame;
};

Spec = (function() {

  function Spec(name) {
    this.name = name;
  }

  return Spec;

})();

ByteSpec = (function(_super) {

  __extends(ByteSpec, _super);

  function ByteSpec(name) {
    if (!(this instanceof ByteSpec)) {
      return (function(func, args, ctor) {
        ctor.prototype = func.prototype;
        var child = new ctor, result = func.apply(child, args), t = typeof result;
        return t == "object" || t == "function" ? result || child : child;
      })(ByteSpec, arguments, function(){});
    }
    ByteSpec.__super__.constructor.call(this, name);
  }

  ByteSpec.prototype.read = function(frame, data) {
    return [data.toString('utf8', 0, 1).charCodeAt(0), data.slice(1)];
  };

  return ByteSpec;

})(Spec);

EncodingSpec = (function(_super) {

  __extends(EncodingSpec, _super);

  function EncodingSpec(name) {
    if (!(this instanceof EncodingSpec)) {
      return (function(func, args, ctor) {
        ctor.prototype = func.prototype;
        var child = new ctor, result = func.apply(child, args), t = typeof result;
        return t == "object" || t == "function" ? result || child : child;
      })(EncodingSpec, arguments, function(){});
    }
    EncodingSpec.__super__.constructor.call(this, name);
  }

  EncodingSpec.prototype.read = function(frame, data) {
    var enc, _ref;
    _ref = EncodingSpec.__super__.read.apply(this, arguments), enc = _ref[0], data = _ref[1];
    if (enc < 16) {
      return [enc, data];
    } else {
      return [0, String.fromCharCode(enc) + data];
    }
  };

  return EncodingSpec;

})(ByteSpec);

MultiSpec = (function(_super) {

  __extends(MultiSpec, _super);

  function MultiSpec() {
    var name, sep, specs, _i;
    name = arguments[0], specs = 3 <= arguments.length ? __slice.call(arguments, 1, _i = arguments.length - 1) : (_i = 1, []), sep = arguments[_i++];
    if (!(this instanceof MultiSpec)) {
      Array.prototype.unshift.call(arguments, null);
      return new (Function.prototype.bind.apply(MultiSpec, arguments));
    }
    this.specs = specs;
    this.sep = sep;
    MultiSpec.__super__.constructor.call(this, name);
  }

  MultiSpec.prototype.read = function(frame, data) {
    var record, spec, value, values, _i, _len, _ref, _ref1;
    values = [];
    while (data.length) {
      record = [];
      _ref = this.specs;
      for (_i = 0, _len = _ref.length; _i < _len; _i++) {
        spec = _ref[_i];
        _ref1 = spec.read(frame, data), value = _ref1[0], data = _ref1[1];
        record.push(value);
      }
      if (this.specs.length !== 1) {
        values.push(record);
      } else {
        values.push(record[0]);
      }
    }
    return [values, data];
  };

  return MultiSpec;

})(Spec);

EncodedTextSpec = (function(_super) {

  __extends(EncodedTextSpec, _super);

  function EncodedTextSpec(name) {
    if (!(this instanceof EncodedTextSpec)) {
      return (function(func, args, ctor) {
        ctor.prototype = func.prototype;
        var child = new ctor, result = func.apply(child, args), t = typeof result;
        return t == "object" || t == "function" ? result || child : child;
      })(EncodedTextSpec, arguments, function(){});
    }
    this._encodings = [[fromLatin1ToString, '00'], [fromUTF16ToString, '0000'], [fromUTF16BEToString, '0000'], [fromUTF8ToString, '00']];
    EncodedTextSpec.__super__.constructor.call(this, name);
  }

  EncodedTextSpec.prototype.read = function(frame, data) {
    var decode, grouping, hexArr, hexStr, offset, ret, stringOffset, term, _ref, _ref1;
    _ref = this._encodings[frame.encoding], decode = _ref[0], term = _ref[1];
    hexStr = data.toString('hex');
    grouping = term.length === 2 ? /(.{2})/g : /(.{4})/g;
    hexArr = hexStr.match(grouping);
    ret = '';
    offset = hexArr.indexOf(term);
    if (offset !== -1) {
      stringOffset = offset * term.length;
      _ref1 = [hexStr.slice(0, stringOffset), hexStr.slice(stringOffset + term.length)], data = _ref1[0], ret = _ref1[1];
    }
    if (typeof data === 'string') {
      data = new Buffer(data, 'hex');
    }
    ret = new Buffer(ret, 'hex');
    if (data.length < term.length) {
      return ['', ret];
    }
    return [decode(data), ret];
  };

  return EncodedTextSpec;

})(Spec);

EncodedNumericTextSpec = (function(_super) {

  __extends(EncodedNumericTextSpec, _super);

  function EncodedNumericTextSpec() {
    return EncodedNumericTextSpec.__super__.constructor.apply(this, arguments);
  }

  return EncodedNumericTextSpec;

})(EncodedTextSpec);

TextFrame = (function(_super) {
  var sep;

  __extends(TextFrame, _super);

  function TextFrame() {
    return TextFrame.__super__.constructor.apply(this, arguments);
  }

  TextFrame.prototype.framespec = [EncodingSpec('encoding'), MultiSpec('text', EncodedTextSpec('text'), sep = '\u0000')];

  return TextFrame;

})(Frame);

NumericTextFrame = (function(_super) {

  __extends(NumericTextFrame, _super);

  function NumericTextFrame() {
    return NumericTextFrame.__super__.constructor.apply(this, arguments);
  }

  NumericTextFrame.prototype.framespec = [EncodingSpec('encoding'), MultiSpec('text', EncodedNumericTextSpec('text'), '\u0000')];

  return NumericTextFrame;

})(TextFrame);

FRAMES = {
  "AENC": "Audio encryption",
  "APIC": "Attached picture",
  "COMM": "Comments",
  "COMR": "Commercial frame",
  "ENCR": "Encryption method registration",
  "EQUA": "Equalization",
  "ETCO": "Event timing codes",
  "GEOB": "General encapsulated object",
  "GRID": "Group identification registration",
  "IPLS": "Involved people list",
  "LINK": "Linked information",
  "MCDI": "Music CD identifier",
  "MLLT": "MPEG location lookup table",
  "OWNE": "Ownership frame",
  "PRIV": "Private frame",
  "PCNT": "Play counter",
  "POPM": "Popularimeter",
  "POSS": "Position synchronisation frame",
  "RBUF": "Recommended buffer size",
  "RVAD": "Relative volume adjustment",
  "RVRB": "Reverb",
  "SYLT": "Synchronized lyric/text",
  "SYTC": "Synchronized tempo codes",
  "TALB": "Album/Movie/Show title",
  "TBPM": "BPM (beats per minute)",
  "TCOM": "Composer",
  "TCON": "Content type",
  "TCOP": "Copyright message",
  "TDAT": "Date",
  "TDLY": "Playlist delay",
  "TENC": "Encoded by",
  "TEXT": "Lyricist/Text writer",
  "TFLT": "File type",
  "TIME": "Time",
  "TIT1": "Content group description",
  "TIT2": "Title/songname/content description",
  "TIT3": "Subtitle/Description refinement",
  "TKEY": "Initial key",
  "TLAN": "Language(s)",
  "TLEN": "Length",
  "TMED": "Media type",
  "TOAL": "Original album/movie/show title",
  "TOFN": "Original filename",
  "TOLY": "Original lyricist(s)/text writer(s)",
  "TOPE": "Original artist(s)/performer(s)",
  "TORY": "Original release year",
  "TOWN": "File owner/licensee",
  "TPE1": "Lead performer(s)/Soloist(s)",
  "TPE2": "Band/orchestra/accompaniment",
  "TPE3": "Conductor/performer refinement",
  "TPE4": "Interpreted, remixed, or otherwise modified by",
  "TPOS": "Part of a set",
  "TPUB": "Publisher",
  "TRCK": "Track number/Position in set",
  "TRDA": "Recording dates",
  "TRSN": "Internet radio station name",
  "TRSO": "Internet radio station owner",
  "TSIZ": "Size",
  "TSRC": "ISRC (international standard recording code)",
  "TSSE": "Software/Hardware and settings used for encoding",
  "TYER": "Year",
  "TXXX": "User defined text information frame",
  "UFID": "Unique file identifier",
  "USER": "Terms of use",
  "USLT": "Unsychronized lyric/text transcription",
  "WCOM": "Commercial information",
  "WCOP": "Copyright/Legal information",
  "WOAF": "Official audio file webpage",
  "WOAR": "Official artist/performer webpage",
  "WOAS": "Official audio source webpage",
  "WORS": "Official internet radio station homepage",
  "WPAY": "Payment",
  "WPUB": "Publishers official webpage",
  "WXXX": "User defined URL link frame"
};

$FRAMES = [
  TALB = (function(_super) {

    __extends(TALB, _super);

    function TALB() {
      return TALB.__super__.constructor.apply(this, arguments);
    }

    return TALB;

  })(TextFrame), TBPM = (function(_super) {

    __extends(TBPM, _super);

    function TBPM() {
      return TBPM.__super__.constructor.apply(this, arguments);
    }

    return TBPM;

  })(NumericTextFrame), TCOM = (function(_super) {

    __extends(TCOM, _super);

    function TCOM() {
      return TCOM.__super__.constructor.apply(this, arguments);
    }

    return TCOM;

  })(TextFrame), TCOP = (function(_super) {

    __extends(TCOP, _super);

    function TCOP() {
      return TCOP.__super__.constructor.apply(this, arguments);
    }

    return TCOP;

  })(TextFrame), TCMP = (function(_super) {

    __extends(TCMP, _super);

    function TCMP() {
      return TCMP.__super__.constructor.apply(this, arguments);
    }

    return TCMP;

  })(NumericTextFrame), TDAT = (function(_super) {

    __extends(TDAT, _super);

    function TDAT() {
      return TDAT.__super__.constructor.apply(this, arguments);
    }

    return TDAT;

  })(TextFrame), TIME = (function(_super) {

    __extends(TIME, _super);

    function TIME() {
      return TIME.__super__.constructor.apply(this, arguments);
    }

    return TIME;

  })(TextFrame), TIT1 = (function(_super) {

    __extends(TIT1, _super);

    function TIT1() {
      return TIT1.__super__.constructor.apply(this, arguments);
    }

    return TIT1;

  })(TextFrame), TIT2 = (function(_super) {

    __extends(TIT2, _super);

    function TIT2() {
      return TIT2.__super__.constructor.apply(this, arguments);
    }

    return TIT2;

  })(TextFrame), TIT3 = (function(_super) {

    __extends(TIT3, _super);

    function TIT3() {
      return TIT3.__super__.constructor.apply(this, arguments);
    }

    return TIT3;

  })(TextFrame), TPE1 = (function(_super) {

    __extends(TPE1, _super);

    function TPE1() {
      return TPE1.__super__.constructor.apply(this, arguments);
    }

    return TPE1;

  })(TextFrame), TPE2 = (function(_super) {

    __extends(TPE2, _super);

    function TPE2() {
      return TPE2.__super__.constructor.apply(this, arguments);
    }

    return TPE2;

  })(TextFrame), TPE3 = (function(_super) {

    __extends(TPE3, _super);

    function TPE3() {
      return TPE3.__super__.constructor.apply(this, arguments);
    }

    return TPE3;

  })(TextFrame), TPE4 = (function(_super) {

    __extends(TPE4, _super);

    function TPE4() {
      return TPE4.__super__.constructor.apply(this, arguments);
    }

    return TPE4;

  })(TextFrame), TYER = (function(_super) {

    __extends(TYER, _super);

    function TYER() {
      return TYER.__super__.constructor.apply(this, arguments);
    }

    return TYER;

  })(NumericTextFrame)
];

for (_i = 0, _len = $FRAMES.length; _i < _len; _i++) {
  cls = $FRAMES[_i];
  FRAMES[cls] = cls;
}

FRAMES_2_2 = {
  "BUF": "Recommended buffer size",
  "CNT": "Play counter",
  "COM": "Comments",
  "CRA": "Audio encryption",
  "CRM": "Encrypted meta frame",
  "ETC": "Event timing codes",
  "EQU": "Equalization",
  "GEO": "General encapsulated object",
  "IPL": "Involved people list",
  "LNK": "Linked information",
  "MCI": "Music CD Identifier",
  "MLL": "MPEG location lookup table",
  "PIC": "Attached picture",
  "POP": "Popularimeter",
  "REV": "Reverb",
  "RVA": "Relative volume adjustment",
  "SLT": "Synchronized lyric/text",
  "STC": "Synced tempo codes",
  "TAL": "Album/Movie/Show title",
  "TBP": "BPM (Beats Per Minute)",
  "TCM": "Composer",
  "TCO": "Content type",
  "TCR": "Copyright message",
  "TDA": "Date",
  "TDY": "Playlist delay",
  "TEN": "Encoded by",
  "TFT": "File type",
  "TIM": "Time",
  "TKE": "Initial key",
  "TLA": "Language(s)",
  "TLE": "Length",
  "TMT": "Media type",
  "TOA": "Original artist(s)/performer(s)",
  "TOF": "Original filename",
  "TOL": "Original Lyricist(s)/text writer(s)",
  "TOR": "Original release year",
  "TOT": "Original album/Movie/Show title",
  "TP1": "Lead artist(s)/Lead performer(s)/Soloist(s)/Performing group",
  "TP2": "Band/Orchestra/Accompaniment",
  "TP3": "Conductor/Performer refinement",
  "TP4": "Interpreted, remixed, or otherwise modified by",
  "TPA": "Part of a set",
  "TPB": "Publisher",
  "TRC": "ISRC (International Standard Recording Code)",
  "TRD": "Recording dates",
  "TRK": "Track number/Position in set",
  "TSI": "Size",
  "TSS": "Software/hardware and settings used for encoding",
  "TT1": "Content group description",
  "TT2": "Title/Songname/Content description",
  "TT3": "Subtitle/Description refinement",
  "TXT": "Lyricist/text writer",
  "TXX": "User defined text information frame",
  "TYE": "Year",
  "UFI": "Unique file identifier",
  "ULT": "Unsychronized lyric/text transcription",
  "WAF": "Official audio file webpage",
  "WAR": "Official artist/performer webpage",
  "WAS": "Official audio source webpage",
  "WCM": "Commercial information",
  "WCP": "Copyright/Legal information",
  "WPB": "Publishers official webpage",
  "WXX": "User defined URL link frame"
};
