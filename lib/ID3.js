// Generated by CoffeeScript 1.3.3
var $FRAMES, $FRAMES_2_2, BaseError, BitPaddedInt, ByteSpec, EOFError, EncodedNumericPartTextSpec, EncodedNumericTextSpec, EncodedTextSpec, EncodingSpec, FRAMES, FRAMES_2_2, Frame, ID3, ID3NoHeaderError, ID3TimeStamp, ID3UnsupportedVersionError, Iconv, MultiSpec, NumericPartTextFrame, NumericTextFrame, ParseID3v1, Spec, TAL, TALB, TBP, TBPM, TCM, TCMP, TCO, TCOM, TCOP, TCR, TDA, TDAT, TDEN, TDOR, TDRC, TDRL, TDTG, TIM, TIME, TIT1, TIT2, TIT3, TLE, TLEN, TP1, TP2, TP3, TP4, TPA, TPE1, TPE2, TPE3, TPE4, TPOS, TRCK, TRK, TT1, TT2, TT3, TYE, TYER, TextFrame, TimeStampSpec, TimeStampTextFrame, cls, convertToString, fromLatin1ToString, fromUTF16BEToString, fromUTF16ToString, fromUTF8ToString, fs, latin1ToUTF8, sprintf, utf16, utf16be, _, _i, _j, _len, _len1,
  __hasProp = {}.hasOwnProperty,
  __extends = function(child, parent) { for (var key in parent) { if (__hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },
  __slice = [].slice;

fs = require('fs');

_ = require('underscore');

sprintf = require("sprintf-js").sprintf;

Iconv = require('iconv').Iconv;

BitPaddedInt = require('./BitPaddedInt.js');

BaseError = require('./errors.js').BaseError;

EOFError = require('./errors.js').EOFError;

ID3NoHeaderError = (function(_super) {

  __extends(ID3NoHeaderError, _super);

  function ID3NoHeaderError() {
    return ID3NoHeaderError.__super__.constructor.apply(this, arguments);
  }

  return ID3NoHeaderError;

})(BaseError);

ID3UnsupportedVersionError = (function(_super) {

  __extends(ID3UnsupportedVersionError, _super);

  function ID3UnsupportedVersionError() {
    return ID3UnsupportedVersionError.__super__.constructor.apply(this, arguments);
  }

  return ID3UnsupportedVersionError;

})(BaseError);

latin1ToUTF8 = new Iconv('ISO-8859-1', 'UTF-8');

utf16 = new Iconv('UTF-16', 'UTF-8');

utf16be = new Iconv('UTF-16BE', 'UTF-8');

convertToString = function(iconv) {
  return function(buffer) {
    return (iconv.convert(buffer)).toString();
  };
};

fromLatin1ToString = convertToString(latin1ToUTF8);

fromUTF16ToString = convertToString(utf16);

fromUTF16BEToString = convertToString(utf16be);

fromUTF8ToString = function(buff) {
  return buff.toString();
};

ID3 = (function() {

  function ID3(filepath) {
    this.__readbytes = 0;
    this.unknownFrames = [];
    if (filepath != null) {
      this.load(filepath);
    }
  }

  ID3.prototype.fullRead = function(size) {
    var buff, bytesRead;
    if (size < 0) {
      throw new Error("Requested bytes " + size + " less than zero");
    }
    if (size > this.__filesize) {
      throw new EOFError("Requested " + size + " of " + this.__filesize + " " + this.filepath);
    }
    buff = new Buffer(size);
    bytesRead = fs.readSync(this.__fileobj, buff, 0, size, this.__readbytes);
    if (bytesRead !== size) {
      throw new EOFError('End of file');
    }
    this.__readbytes += bytesRead;
    return buff;
  };

  ID3.prototype.load = function(filepath) {
    var data, frame, frames, headerLoaded, name, readFrame, _results;
    this.filepath = filepath;
    this.__fileobj = fs.openSync(filepath, 'r');
    this.__filesize = fs.statSync(filepath).size;
    try {
      headerLoaded = false;
      try {
        this.loadHeader();
        return headerLoaded = true;
      } catch (err) {
        if (err instanceof EOFError) {
          this.size = 0;
          throw new ID3NoHeaderError("" + this.filepath + ": too small (" + this.__filesize + " bytes)");
        } else if (err instanceof ID3NoHeaderError || err instanceof ID3UnsupportedVersionError) {
          this.size = 0;
          if (this.__filesize >= 128) {
            this.__readbytes = this.__filesize - 128;
            frames = ParseID3v1(this.fullRead(128));
            if (frames) {
              this.version.majorRev = 1;
              this.version.minorRev = 1;
              _results = [];
              for (name in frames) {
                frame = frames[name];
                _results.push(this.add(frame));
              }
              return _results;
            } else {
              throw err;
            }
          } else {
            throw err;
          }
        }
      } finally {
        if (headerLoaded) {
          if (this.version.majorRev >= 3) {
            frames = FRAMES;
          } else if (this.version.majorRev <= 2) {
            frames = FRAMES_2_2;
          }
          data = this.fullRead(this.size - 10);
          readFrame = this.getFrameReader(data, frames);
          frame = false;
          while ((frame = readFrame()) !== false) {
            if (frame instanceof Frame) {
              this.add(frame);
            } else if (frame != null) {
              this.unknownFrames.push(frame);
            }
          }
        }
      }
    } finally {
      fs.closeSync(this.__fileobj);
      this.__fileobj = null;
      this.__filesize = null;
    }
  };

  ID3.prototype.add = function(frame) {
    return this[frame.HashKey] = frame;
  };

  ID3.prototype.loadHeader = function() {
    var data, extSizeRepr, flags, id3, offset, sizeRepr, _ref;
    data = this.fullRead(10);
    offset = 0;
    id3 = fromLatin1ToString(data.slice(offset, offset += 3));
    this.version = {
      majorRev: data.readUInt8(offset++),
      minorRev: data.readUInt8(offset++)
    };
    flags = data.readUInt8(offset++);
    this.f_unsynch = (flags & 0x80) !== 0;
    this.f_extended = (flags & 0x40) !== 0;
    this.f_experimental = (flags & 0x20) !== 0;
    this.f_footer = (flags & 0x10) !== 0;
    sizeRepr = fromLatin1ToString(data.slice(offset, offset += 4));
    this.size = BitPaddedInt(sizeRepr) + 10;
    if (id3 !== 'ID3') {
      throw new ID3NoHeaderError("" + this.filepath + " doesn't start with an ID3 tag");
    }
    if ((_ref = this.version.majorRev) !== 2 && _ref !== 3 && _ref !== 4) {
      throw new ID3UnsupportedVersionError("" + this.filepath + " ID3v2." + this.version.majorRev + " not supported");
    }
    if (this.f_extended) {
      data = this.fullRead(4);
      extSizeRepr = fromLatin1ToString(data);
      if (_.include(FRAMES, extSizeRepr)) {
        this.f_extended = false;
        this.__extsize = 0;
        this.__readbytes -= 4;
      } else if (this.version.majorRev >= 4) {
        this.__extsize = BitPaddedInt(extSizeRepr) - 4;
      } else {
        this.__extsize = BitPaddedInt(extSizeRepr, 8);
      }
      this.__extdata = '';
      if (this.__extsize) {
        data = this.fullRead(this.__extsize);
        return this.__extdata = data.toString('hex');
      }
    }
  };

  ID3.prototype.getFrameReader = function(data, frames) {
    var bpi, reader,
      _this = this;
    if (3 <= this.version.majorRev) {
      bpi = this.determineBPI(data, frames);
      return reader = function() {
        var flags, framedata, header, name, offset, size, tag;
        while (true) {
          try {
            header = data.slice(0, 10);
            offset = 0;
            name = fromLatin1ToString(header.slice(offset, offset += 4));
            size = header.readUInt32BE(offset);
            offset += 4;
            flags = header.readUInt16BE(offset);
          } catch (err) {
            console.log(_this.filepath);
            console.log(err.stack, '\n');
            return false;
          }
          if ((name.replace(/[\x00]+$/g, '')) === '') {
            return false;
          }
          size = bpi(size);
          framedata = data.slice(10, 10 + size);
          data = data.slice(10 + size);
          if (!(size === 0)) {
            break;
          }
        }
        tag = frames[name];
        if (tag === void 0 || typeof tag === 'string') {
          if (Frame.isValidFrameId(name)) {
            return header + framedata;
          }
        } else {
          try {
            return _this.loadFramedata(tag, flags, framedata);
          } catch (err) {
            console.log(_this.filepath);
            return console.log(err.stack, '\n');
          }
        }
      };
    } else if (2 <= this.version.majorRev) {
      return reader = function() {
        var framedata, header, name, offset, size, tag;
        while (true) {
          try {
            header = data.slice(0, 6);
            offset = 0;
            name = fromLatin1ToString(header.slice(offset, offset += 3));
            size = header.slice(offset, offset += 3);
          } catch (err) {
            console.log(_this.filepath);
            console.log(err.stack, '\n');
            return false;
          }
          size = Buffer.concat([new Buffer('00', 'hex'), size]);
          size = size.readUInt32BE(0);
          if ((name.replace(/[\x00]+$/g, '')) === '') {
            return false;
          }
          framedata = data.slice(6, 6 + size);
          data = data.slice(6 + size);
          if (!(size === 0)) {
            break;
          }
        }
        tag = frames[name];
        if (tag === void 0 || typeof tag === 'string') {
          if (Frame.isValidFrameId(name)) {
            return header + framedata;
          }
        } else {
          try {
            return _this.loadFramedata(tag, 0, framedata);
          } catch (err) {
            console.log(_this.filepath);
            return console.log(err.stack, '\n');
          }
        }
      };
    }
  };

  ID3.prototype.loadFramedata = function(tag, flags, data) {
    return tag.fromData(tag, this, flags, data);
  };

  ID3.prototype.determineBPI = function(data, frames) {
    var EMPTY, asbpi, asint, bpioff, flags, intoff, name, o, part, size;
    EMPTY = "\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00";
    if (this.version.majorRev < 4) {
      return function(i) {
        return parseInt(i, 10);
      };
    }
    o = 0;
    asbpi = 0;
    while (o < (data.length - 10)) {
      part = data.slice(o, o + 10);
      if (part === EMPTY) {
        bpioff = -((data.length - o) % 10);
        break;
      }
      name = fromLatin1ToString(part.slice(0, 4));
      size = part.readUInt32BE(4);
      flags = part.readUInt16BE(8);
      size = BitPaddedInt(size);
      o += 10 + size;
      if (frames[name] != null) {
        asbpi++;
      }
      if (!o < (data.length - 10)) {
        bpioff = o - data.length;
      }
    }
    o = 0;
    asint = 0;
    while (o < (data.length - 10)) {
      part = data.slice(o, o + 10);
      if (part === EMPTY) {
        intoff = -((data.length - o) % 10);
        break;
      }
      name = fromLatin1ToString(part.slice(0, 4));
      size = part.readUInt32BE(4);
      flags = part.readUInt16BE(8);
      o += 10 + size;
      if (frames[name] != null) {
        asint++;
      }
      if (!o < (data.length - 10)) {
        intoff = o - data.length;
      }
    }
    if ((asint > asbpi) || ((asint === asbpi) && ((bpioff >= 1) && (intoff <= 1)))) {
      return function(i) {
        return parseInt(i, 10);
      };
    }
    return function(i) {
      return BitPaddedInt(i);
    };
  };

  return ID3;

})();

module.exports = ID3;

Frame = (function() {

  function Frame() {
    var blah, checker, kwargs, validated, _i, _len, _ref;
    Object.defineProperty(this, 'FrameID', {
      enumerable: true,
      get: function() {
        return this.constructor.name;
      }
    });
    Object.defineProperty(this, 'HashKey', {
      enumerable: true,
      get: function() {
        return this.FrameID;
      }
    });
    if (!(arguments.length > 0)) {
      return this;
    }
    if (false) {
      blah = false;
    } else {
      kwargs = arguments[0];
      _ref = this.framespec;
      for (_i = 0, _len = _ref.length; _i < _len; _i++) {
        checker = _ref[_i];
        validated = checker.validate(this, kwargs[checker.name]);
        this[checker.name] = validated;
      }
    }
  }

  Frame.prototype._readData = function(data) {
    var odata, spec, value, _i, _len, _ref, _ref1, _results;
    odata = data;
    _ref = this.framespec;
    _results = [];
    for (_i = 0, _len = _ref.length; _i < _len; _i++) {
      spec = _ref[_i];
      if (!(data.length > 0)) {
        throw new Error('ID3JunkFrameError');
      }
      _ref1 = spec.read(this, data), value = _ref1[0], data = _ref1[1];
      _results.push(this[spec.name] = value);
    }
    return _results;
  };

  return Frame;

})();

Frame.isValidFrameId = function(frameId) {
  var char, i, isAlphaNumeric, lowerBound, lowerBound1, upperBound, upperBound1, _i, _ref;
  upperBound = 'Z'.charCodeAt(0);
  lowerBound = 'A'.charCodeAt(0);
  upperBound1 = '9'.charCodeAt(0);
  lowerBound1 = '0'.charCodeAt(0);
  isAlphaNumeric = true;
  for (i = _i = 0, _ref = frameId.length; 0 <= _ref ? _i <= _ref : _i >= _ref; i = 0 <= _ref ? ++_i : --_i) {
    char = frameId.charCodeAt(i);
    if (char <= upperBound && char >= lowerBound) {
      continue;
    } else if (char <= upperBound1 && char >= lowerBound1) {
      continue;
    } else {
      isAlphaNumeric = false;
    }
  }
  return isAlphaNumeric;
};

Frame.fromData = function(cls, id3, tflags, data) {
  var frame;
  if (4 <= id3.version.majorRev) {
    true;
  } else if (3 <= id3.version.majorRev) {
    true;
  }
  frame = new cls();
  frame._rawdata = data;
  frame._readData(data);
  return frame;
};

Spec = (function() {

  function Spec(name) {
    this.name = name;
  }

  return Spec;

})();

ByteSpec = (function(_super) {

  __extends(ByteSpec, _super);

  function ByteSpec(name) {
    if (!(this instanceof ByteSpec)) {
      return (function(func, args, ctor) {
        ctor.prototype = func.prototype;
        var child = new ctor, result = func.apply(child, args), t = typeof result;
        return t == "object" || t == "function" ? result || child : child;
      })(ByteSpec, arguments, function(){});
    }
    ByteSpec.__super__.constructor.call(this, name);
  }

  ByteSpec.prototype.read = function(frame, data) {
    return [data.toString('utf8', 0, 1).charCodeAt(0), data.slice(1)];
  };

  ByteSpec.prototype.validate = function(frame, value) {
    return value;
  };

  return ByteSpec;

})(Spec);

EncodingSpec = (function(_super) {

  __extends(EncodingSpec, _super);

  function EncodingSpec(name) {
    if (!(this instanceof EncodingSpec)) {
      return (function(func, args, ctor) {
        ctor.prototype = func.prototype;
        var child = new ctor, result = func.apply(child, args), t = typeof result;
        return t == "object" || t == "function" ? result || child : child;
      })(EncodingSpec, arguments, function(){});
    }
    EncodingSpec.__super__.constructor.call(this, name);
  }

  EncodingSpec.prototype.read = function(frame, data) {
    var enc, _ref;
    _ref = EncodingSpec.__super__.read.apply(this, arguments), enc = _ref[0], data = _ref[1];
    if (enc < 16) {
      return [enc, data];
    } else {
      return [0, String.fromCharCode(enc) + data];
    }
  };

  EncodingSpec.prototype.validate = function(frame, value) {
    if ((0 <= value && value <= 3)) {
      return value;
    }
    if (!value) {
      return null;
    }
    throw new Error("Invalid Encoding: " + value);
  };

  return EncodingSpec;

})(ByteSpec);

MultiSpec = (function(_super) {

  __extends(MultiSpec, _super);

  function MultiSpec() {
    var name, sep, specs, _i;
    name = arguments[0], specs = 3 <= arguments.length ? __slice.call(arguments, 1, _i = arguments.length - 1) : (_i = 1, []), sep = arguments[_i++];
    if (!(this instanceof MultiSpec)) {
      Array.prototype.unshift.call(arguments, null);
      return new (Function.prototype.bind.apply(MultiSpec, arguments));
    }
    this.specs = specs;
    this.sep = sep;
    MultiSpec.__super__.constructor.call(this, name);
  }

  MultiSpec.prototype.read = function(frame, data) {
    var record, spec, value, values, _i, _len, _ref, _ref1;
    values = [];
    while (data.length) {
      record = [];
      _ref = this.specs;
      for (_i = 0, _len = _ref.length; _i < _len; _i++) {
        spec = _ref[_i];
        _ref1 = spec.read(frame, data), value = _ref1[0], data = _ref1[1];
        record.push(value);
      }
      if (this.specs.length !== 1) {
        values.push(record);
      } else {
        values.push(record[0]);
      }
    }
    return [values, data];
  };

  MultiSpec.prototype.validate = function(frame, value) {
    var v;
    if (!value) {
      return [];
    }
    if (this.sep && _.isString(value)) {
      value = value.split(this.sep);
    }
    if (_.isArray(value)) {
      if (this.specs.length === 1) {
        return (function() {
          var _i, _len, _results;
          _results = [];
          for (_i = 0, _len = value.length; _i < _len; _i++) {
            v = value[_i];
            _results.push(this.specs[0].validate(frame, v));
          }
          return _results;
        }).call(this);
      }
      throw new Error("Invalid MultiSpec data: " + value);
    }
  };

  return MultiSpec;

})(Spec);

EncodedTextSpec = (function(_super) {

  __extends(EncodedTextSpec, _super);

  function EncodedTextSpec(name) {
    if (!(this instanceof EncodedTextSpec)) {
      return (function(func, args, ctor) {
        ctor.prototype = func.prototype;
        var child = new ctor, result = func.apply(child, args), t = typeof result;
        return t == "object" || t == "function" ? result || child : child;
      })(EncodedTextSpec, arguments, function(){});
    }
    this._encodings = [[fromLatin1ToString, '00'], [fromUTF16ToString, '0000'], [fromUTF16BEToString, '0000'], [fromUTF8ToString, '00']];
    EncodedTextSpec.__super__.constructor.call(this, name);
  }

  EncodedTextSpec.prototype.read = function(frame, data) {
    var decode, grouping, hexArr, hexStr, offset, ret, stringOffset, term, _ref, _ref1;
    _ref = this._encodings[frame.encoding], decode = _ref[0], term = _ref[1];
    hexStr = data.toString('hex');
    grouping = term.length === 2 ? /(.{2})/g : /(.{4})/g;
    hexArr = hexStr.match(grouping);
    ret = '';
    offset = hexArr.indexOf(term);
    if (offset !== -1) {
      stringOffset = offset * term.length;
      _ref1 = [hexStr.slice(0, stringOffset), hexStr.slice(stringOffset + term.length)], data = _ref1[0], ret = _ref1[1];
    }
    if (typeof data === 'string') {
      data = new Buffer(data, 'hex');
    }
    ret = new Buffer(ret, 'hex');
    if (data.length < term.length) {
      return ['', ret];
    }
    return [decode(data), ret];
  };

  EncodedTextSpec.prototype.validate = function(frame, value) {
    return value;
  };

  return EncodedTextSpec;

})(Spec);

EncodedNumericTextSpec = (function(_super) {

  __extends(EncodedNumericTextSpec, _super);

  function EncodedNumericTextSpec() {
    return EncodedNumericTextSpec.__super__.constructor.apply(this, arguments);
  }

  return EncodedNumericTextSpec;

})(EncodedTextSpec);

EncodedNumericPartTextSpec = (function(_super) {

  __extends(EncodedNumericPartTextSpec, _super);

  function EncodedNumericPartTextSpec() {
    return EncodedNumericPartTextSpec.__super__.constructor.apply(this, arguments);
  }

  return EncodedNumericPartTextSpec;

})(EncodedTextSpec);

ID3TimeStamp = (function() {

  function ID3TimeStamp(text) {
    Object.defineProperty(this, 'text', {
      enumerable: true,
      get: function() {
        var formats, idx, part, parts, pieces, seps, _i, _len;
        formats = ['%04d', '%02d', '%02d', '%02d', '%02d', '%02d'];
        seps = ['-', '-', ' ', ':', ':', 'x'];
        parts = [this.year, this.month, this.day, this.hour, this.minute, this.second];
        pieces = [];
        for (idx = _i = 0, _len = parts.length; _i < _len; idx = ++_i) {
          part = parts[idx];
          if (part !== null) {
            pieces.push(sprintf(formats[idx], part) + seps[idx]);
          }
        }
        return pieces.join('').slice(0, -1);
      },
      set: function(text) {
        var splitre, unit, units, v, values, _ref, _results;
        splitre = /[-T:/.]|\s+/;
        units = 'year month day hour minute second'.split(' ');
        values = (text + ':::::').split(splitre).slice(0, 6);
        _ref = _.object(units, values);
        _results = [];
        for (unit in _ref) {
          v = _ref[unit];
          v = parseInt(v, 10);
          if (_.isNaN(v)) {
            v = null;
          }
          _results.push(this[unit] = v);
        }
        return _results;
      }
    });
    if (text instanceof ID3TimeStamp) {
      text = text.text;
    }
    this.text = text;
  }

  ID3TimeStamp.prototype.toString = function() {
    return this.text;
  };

  ID3TimeStamp.prototype.valueOf = function() {
    return this.text;
  };

  return ID3TimeStamp;

})();

TimeStampSpec = (function(_super) {

  __extends(TimeStampSpec, _super);

  function TimeStampSpec(name) {
    if (!(this instanceof TimeStampSpec)) {
      return (function(func, args, ctor) {
        ctor.prototype = func.prototype;
        var child = new ctor, result = func.apply(child, args), t = typeof result;
        return t == "object" || t == "function" ? result || child : child;
      })(TimeStampSpec, arguments, function(){});
    }
    TimeStampSpec.__super__.constructor.call(this, name);
  }

  TimeStampSpec.prototype.read = function(frame, data) {
    var value, _ref;
    _ref = TimeStampSpec.__super__.read.apply(this, arguments), value = _ref[0], data = _ref[1];
    return [this.validate(frame, value), data];
  };

  TimeStampSpec.prototype.validate = function(frame, value) {
    try {
      return new ID3TimeStamp(value);
    } catch (err) {
      throw new RangeError("Invalid ID3TimeStamp: " + value);
    }
  };

  return TimeStampSpec;

})(EncodedTextSpec);

TextFrame = (function(_super) {
  var sep;

  __extends(TextFrame, _super);

  function TextFrame() {
    return TextFrame.__super__.constructor.apply(this, arguments);
  }

  TextFrame.prototype.framespec = [EncodingSpec('encoding'), MultiSpec('text', EncodedTextSpec('text'), sep = '\u0000')];

  TextFrame.prototype.toString = function() {
    return this.text.join('\u0000');
  };

  TextFrame.prototype.valueOf = function() {
    return this.text;
  };

  return TextFrame;

})(Frame);

NumericTextFrame = (function(_super) {

  __extends(NumericTextFrame, _super);

  function NumericTextFrame() {
    return NumericTextFrame.__super__.constructor.apply(this, arguments);
  }

  NumericTextFrame.prototype.framespec = [EncodingSpec('encoding'), MultiSpec('text', EncodedNumericTextSpec('text'), '\u0000')];

  NumericTextFrame.prototype.valueOf = function() {
    return parseInt(this.text[0], 10);
  };

  return NumericTextFrame;

})(TextFrame);

NumericPartTextFrame = (function(_super) {

  __extends(NumericPartTextFrame, _super);

  function NumericPartTextFrame() {
    return NumericPartTextFrame.__super__.constructor.apply(this, arguments);
  }

  NumericPartTextFrame.prototype.framespec = [EncodingSpec('encoding'), MultiSpec('text', EncodedNumericPartTextSpec('text'), '\u0000')];

  NumericPartTextFrame.prototype.valueOf = function() {
    return parseInt(this.text[0].split('/')[0], 10);
  };

  return NumericPartTextFrame;

})(TextFrame);

TimeStampTextFrame = (function(_super) {
  var sep;

  __extends(TimeStampTextFrame, _super);

  function TimeStampTextFrame() {
    return TimeStampTextFrame.__super__.constructor.apply(this, arguments);
  }

  TimeStampTextFrame.prototype.framespec = [EncodingSpec('encoding'), MultiSpec('text', TimeStampSpec('stamp'), sep = ',')];

  TimeStampTextFrame.prototype.toString = function() {
    var stamp;
    return ((function() {
      var _i, _len, _ref, _results;
      _ref = this.text;
      _results = [];
      for (_i = 0, _len = _ref.length; _i < _len; _i++) {
        stamp = _ref[_i];
        _results.push(stamp.text);
      }
      return _results;
    }).call(this)).join(',');
  };

  return TimeStampTextFrame;

})(TextFrame);

FRAMES = {
  "AENC": "Audio encryption",
  "APIC": "Attached picture",
  "COMM": "Comments",
  "COMR": "Commercial frame",
  "ENCR": "Encryption method registration",
  "EQUA": "Equalization",
  "ETCO": "Event timing codes",
  "GEOB": "General encapsulated object",
  "GRID": "Group identification registration",
  "IPLS": "Involved people list",
  "LINK": "Linked information",
  "MCDI": "Music CD identifier",
  "MLLT": "MPEG location lookup table",
  "OWNE": "Ownership frame",
  "PRIV": "Private frame",
  "PCNT": "Play counter",
  "POPM": "Popularimeter",
  "POSS": "Position synchronisation frame",
  "RBUF": "Recommended buffer size",
  "RVAD": "Relative volume adjustment",
  "RVRB": "Reverb",
  "SYLT": "Synchronized lyric/text",
  "SYTC": "Synchronized tempo codes",
  "TCON": "Content type",
  "TDLY": "Playlist delay",
  "TENC": "Encoded by",
  "TEXT": "Lyricist/Text writer",
  "TFLT": "File type",
  "TKEY": "Initial key",
  "TLAN": "Language(s)",
  "TMED": "Media type",
  "TOAL": "Original album/movie/show title",
  "TOFN": "Original filename",
  "TOLY": "Original lyricist(s)/text writer(s)",
  "TOPE": "Original artist(s)/performer(s)",
  "TORY": "Original release year",
  "TOWN": "File owner/licensee",
  "TPUB": "Publisher",
  "TRDA": "Recording dates",
  "TRSN": "Internet radio station name",
  "TRSO": "Internet radio station owner",
  "TSIZ": "Size",
  "TSRC": "ISRC (international standard recording code)",
  "TSSE": "Software/Hardware and settings used for encoding",
  "TXXX": "User defined text information frame",
  "UFID": "Unique file identifier",
  "USER": "Terms of use",
  "USLT": "Unsychronized lyric/text transcription",
  "WCOM": "Commercial information",
  "WCOP": "Copyright/Legal information",
  "WOAF": "Official audio file webpage",
  "WOAR": "Official artist/performer webpage",
  "WOAS": "Official audio source webpage",
  "WORS": "Official internet radio station homepage",
  "WPAY": "Payment",
  "WPUB": "Publishers official webpage",
  "WXXX": "User defined URL link frame"
};

$FRAMES = [
  TALB = (function(_super) {

    __extends(TALB, _super);

    function TALB() {
      return TALB.__super__.constructor.apply(this, arguments);
    }

    return TALB;

  })(TextFrame), TBPM = (function(_super) {

    __extends(TBPM, _super);

    function TBPM() {
      return TBPM.__super__.constructor.apply(this, arguments);
    }

    return TBPM;

  })(NumericTextFrame), TCOM = (function(_super) {

    __extends(TCOM, _super);

    function TCOM() {
      return TCOM.__super__.constructor.apply(this, arguments);
    }

    return TCOM;

  })(TextFrame), TCOP = (function(_super) {

    __extends(TCOP, _super);

    function TCOP() {
      return TCOP.__super__.constructor.apply(this, arguments);
    }

    return TCOP;

  })(TextFrame), TCMP = (function(_super) {

    __extends(TCMP, _super);

    function TCMP() {
      return TCMP.__super__.constructor.apply(this, arguments);
    }

    return TCMP;

  })(NumericTextFrame), TDAT = (function(_super) {

    __extends(TDAT, _super);

    function TDAT() {
      return TDAT.__super__.constructor.apply(this, arguments);
    }

    return TDAT;

  })(TextFrame), TDRC = (function(_super) {

    __extends(TDRC, _super);

    function TDRC() {
      return TDRC.__super__.constructor.apply(this, arguments);
    }

    return TDRC;

  })(TimeStampTextFrame), TIME = (function(_super) {

    __extends(TIME, _super);

    function TIME() {
      return TIME.__super__.constructor.apply(this, arguments);
    }

    return TIME;

  })(TextFrame), TLEN = (function(_super) {

    __extends(TLEN, _super);

    function TLEN() {
      return TLEN.__super__.constructor.apply(this, arguments);
    }

    return TLEN;

  })(NumericTextFrame), TIT1 = (function(_super) {

    __extends(TIT1, _super);

    function TIT1() {
      return TIT1.__super__.constructor.apply(this, arguments);
    }

    return TIT1;

  })(TextFrame), TIT2 = (function(_super) {

    __extends(TIT2, _super);

    function TIT2() {
      return TIT2.__super__.constructor.apply(this, arguments);
    }

    return TIT2;

  })(TextFrame), TIT3 = (function(_super) {

    __extends(TIT3, _super);

    function TIT3() {
      return TIT3.__super__.constructor.apply(this, arguments);
    }

    return TIT3;

  })(TextFrame), TPE1 = (function(_super) {

    __extends(TPE1, _super);

    function TPE1() {
      return TPE1.__super__.constructor.apply(this, arguments);
    }

    return TPE1;

  })(TextFrame), TPE2 = (function(_super) {

    __extends(TPE2, _super);

    function TPE2() {
      return TPE2.__super__.constructor.apply(this, arguments);
    }

    return TPE2;

  })(TextFrame), TPE3 = (function(_super) {

    __extends(TPE3, _super);

    function TPE3() {
      return TPE3.__super__.constructor.apply(this, arguments);
    }

    return TPE3;

  })(TextFrame), TPE4 = (function(_super) {

    __extends(TPE4, _super);

    function TPE4() {
      return TPE4.__super__.constructor.apply(this, arguments);
    }

    return TPE4;

  })(TextFrame), TPOS = (function(_super) {

    __extends(TPOS, _super);

    function TPOS() {
      return TPOS.__super__.constructor.apply(this, arguments);
    }

    return TPOS;

  })(NumericPartTextFrame), TRCK = (function(_super) {

    __extends(TRCK, _super);

    function TRCK() {
      return TRCK.__super__.constructor.apply(this, arguments);
    }

    return TRCK;

  })(NumericPartTextFrame), TYER = (function(_super) {

    __extends(TYER, _super);

    function TYER() {
      return TYER.__super__.constructor.apply(this, arguments);
    }

    return TYER;

  })(NumericTextFrame), TDEN = (function(_super) {

    __extends(TDEN, _super);

    function TDEN() {
      return TDEN.__super__.constructor.apply(this, arguments);
    }

    return TDEN;

  })(TimeStampTextFrame), TDOR = (function(_super) {

    __extends(TDOR, _super);

    function TDOR() {
      return TDOR.__super__.constructor.apply(this, arguments);
    }

    return TDOR;

  })(TimeStampTextFrame), TDRC = (function(_super) {

    __extends(TDRC, _super);

    function TDRC() {
      return TDRC.__super__.constructor.apply(this, arguments);
    }

    return TDRC;

  })(TimeStampTextFrame), TDRL = (function(_super) {

    __extends(TDRL, _super);

    function TDRL() {
      return TDRL.__super__.constructor.apply(this, arguments);
    }

    return TDRL;

  })(TimeStampTextFrame), TDTG = (function(_super) {

    __extends(TDTG, _super);

    function TDTG() {
      return TDTG.__super__.constructor.apply(this, arguments);
    }

    return TDTG;

  })(TimeStampTextFrame)
];

for (_i = 0, _len = $FRAMES.length; _i < _len; _i++) {
  cls = $FRAMES[_i];
  FRAMES[cls] = cls;
}

FRAMES_2_2 = {
  "BUF": "Recommended buffer size",
  "CNT": "Play counter",
  "COM": "Comments",
  "CRA": "Audio encryption",
  "CRM": "Encrypted meta frame",
  "ETC": "Event timing codes",
  "EQU": "Equalization",
  "GEO": "General encapsulated object",
  "IPL": "Involved people list",
  "LNK": "Linked information",
  "MCI": "Music CD Identifier",
  "MLL": "MPEG location lookup table",
  "PIC": "Attached picture",
  "POP": "Popularimeter",
  "REV": "Reverb",
  "RVA": "Relative volume adjustment",
  "SLT": "Synchronized lyric/text",
  "STC": "Synced tempo codes",
  "TCO": "Content type",
  "TDY": "Playlist delay",
  "TEN": "Encoded by",
  "TFT": "File type",
  "TKE": "Initial key",
  "TLA": "Language(s)",
  "TMT": "Media type",
  "TOA": "Original artist(s)/performer(s)",
  "TOF": "Original filename",
  "TOL": "Original Lyricist(s)/text writer(s)",
  "TOR": "Original release year",
  "TOT": "Original album/Movie/Show title",
  "TPB": "Publisher",
  "TRC": "ISRC (International Standard Recording Code)",
  "TRD": "Recording dates",
  "TSI": "Size",
  "TSS": "Software/hardware and settings used for encoding",
  "TXT": "Lyricist/text writer",
  "TXX": "User defined text information frame",
  "UFI": "Unique file identifier",
  "ULT": "Unsychronized lyric/text transcription",
  "WAF": "Official audio file webpage",
  "WAR": "Official artist/performer webpage",
  "WAS": "Official audio source webpage",
  "WCM": "Commercial information",
  "WCP": "Copyright/Legal information",
  "WPB": "Publishers official webpage",
  "WXX": "User defined URL link frame"
};

$FRAMES_2_2 = [
  TAL = (function(_super) {

    __extends(TAL, _super);

    function TAL() {
      return TAL.__super__.constructor.apply(this, arguments);
    }

    return TAL;

  })(TALB), TBP = (function(_super) {

    __extends(TBP, _super);

    function TBP() {
      return TBP.__super__.constructor.apply(this, arguments);
    }

    return TBP;

  })(TBPM), TCM = (function(_super) {

    __extends(TCM, _super);

    function TCM() {
      return TCM.__super__.constructor.apply(this, arguments);
    }

    return TCM;

  })(TCOM), TCR = (function(_super) {

    __extends(TCR, _super);

    function TCR() {
      return TCR.__super__.constructor.apply(this, arguments);
    }

    return TCR;

  })(TCOP), TCO = (function(_super) {

    __extends(TCO, _super);

    function TCO() {
      return TCO.__super__.constructor.apply(this, arguments);
    }

    return TCO;

  })(TCMP), TDA = (function(_super) {

    __extends(TDA, _super);

    function TDA() {
      return TDA.__super__.constructor.apply(this, arguments);
    }

    return TDA;

  })(TDAT), TIM = (function(_super) {

    __extends(TIM, _super);

    function TIM() {
      return TIM.__super__.constructor.apply(this, arguments);
    }

    return TIM;

  })(TIME), TLE = (function(_super) {

    __extends(TLE, _super);

    function TLE() {
      return TLE.__super__.constructor.apply(this, arguments);
    }

    return TLE;

  })(TLEN), TT1 = (function(_super) {

    __extends(TT1, _super);

    function TT1() {
      return TT1.__super__.constructor.apply(this, arguments);
    }

    return TT1;

  })(TIT1), TT2 = (function(_super) {

    __extends(TT2, _super);

    function TT2() {
      return TT2.__super__.constructor.apply(this, arguments);
    }

    return TT2;

  })(TIT2), TT3 = (function(_super) {

    __extends(TT3, _super);

    function TT3() {
      return TT3.__super__.constructor.apply(this, arguments);
    }

    return TT3;

  })(TIT3), TP1 = (function(_super) {

    __extends(TP1, _super);

    function TP1() {
      return TP1.__super__.constructor.apply(this, arguments);
    }

    return TP1;

  })(TPE1), TP2 = (function(_super) {

    __extends(TP2, _super);

    function TP2() {
      return TP2.__super__.constructor.apply(this, arguments);
    }

    return TP2;

  })(TPE2), TP3 = (function(_super) {

    __extends(TP3, _super);

    function TP3() {
      return TP3.__super__.constructor.apply(this, arguments);
    }

    return TP3;

  })(TPE3), TP4 = (function(_super) {

    __extends(TP4, _super);

    function TP4() {
      return TP4.__super__.constructor.apply(this, arguments);
    }

    return TP4;

  })(TPE4), TPA = (function(_super) {

    __extends(TPA, _super);

    function TPA() {
      return TPA.__super__.constructor.apply(this, arguments);
    }

    return TPA;

  })(TPOS), TRK = (function(_super) {

    __extends(TRK, _super);

    function TRK() {
      return TRK.__super__.constructor.apply(this, arguments);
    }

    return TRK;

  })(TRCK), TYE = (function(_super) {

    __extends(TYE, _super);

    function TYE() {
      return TYE.__super__.constructor.apply(this, arguments);
    }

    return TYE;

  })(TYER)
];

for (_j = 0, _len1 = $FRAMES_2_2.length; _j < _len1; _j++) {
  cls = $FRAMES_2_2[_j];
  FRAMES_2_2[cls] = cls;
}

ParseID3v1 = function(buffer) {
  var album, artist, comment, fix, frames, genre, hexString, offset, str, tag, tagByteLength, title, track, year, _ref;
  hexString = buffer.toString('hex');
  hexString = hexString.slice(hexString.indexOf('544147'));
  if (hexString === -1) {
    return null;
  }
  tagByteLength = Buffer.byteLength(hexString, 'hex');
  if (128 < tagByteLength || tagByteLength < 124) {
    return null;
  }
  buffer = new Buffer(hexString, 'hex');
  try {
    offset = 0;
    tag = fromLatin1ToString(buffer.slice(offset, offset += 3));
    title = fromLatin1ToString(buffer.slice(offset, offset += 30));
    artist = fromLatin1ToString(buffer.slice(offset, offset += 30));
    album = fromLatin1ToString(buffer.slice(offset, offset += 30));
    year = fromLatin1ToString(buffer.slice(offset, offset += tagByteLength - 124));
    comment = fromLatin1ToString(buffer.slice(offset, offset += 29));
    track = buffer.readUInt8(offset++);
    genre = buffer.readUInt8(offset++);
  } catch (err) {
    return null;
  }
  if (tag !== 'TAG') {
    return null;
  }
  fix = function(string) {
    return string.split('\u0000')[0].trim();
  };
  _ref = (function() {
    var _k, _len2, _ref, _results;
    _ref = [title, artist, album, year, comment];
    _results = [];
    for (_k = 0, _len2 = _ref.length; _k < _len2; _k++) {
      str = _ref[_k];
      _results.push(fix(str));
    }
    return _results;
  })(), title = _ref[0], artist = _ref[1], album = _ref[2], year = _ref[3], comment = _ref[4];
  frames = {};
  if (title) {
    frames["TIT2"] = new TIT2({
      encoding: 0,
      text: title
    });
  }
  if (artist) {
    frames["TPE1"] = new TPE1({
      encoding: 0,
      text: [artist]
    });
  }
  if (album) {
    frames["TALB"] = new TALB({
      encoding: 0,
      text: album
    });
  }
  if (year) {
    frames["TDRC"] = new TDRC({
      encoding: 0,
      text: year
    });
  }
  if (track && (track !== 32 || hexString.slice(-6, -4) === '00')) {
    frames["TRCK"] = new TRCK({
      encoding: 0,
      text: track.toString()
    });
  }
  return frames;
};
